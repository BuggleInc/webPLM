
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h2>Trilhas de buggles</h2>

<p>Seu buggle se perdeu num estranho labirinto, e você deve ajudá-lo a achar a
saída que está representada em laranja. Você não pode simplesmente explicar
o caminho para a saída com algo do tipo
<code>direita();avançar();avançar();avançar()</code> por que você tem que
salvar dois buggles ao mesmo tempo, que estão presos em mundos similares mas
não iguais. Você pode alternar para o outro mundo usando o combobox acima da
representação do mundo (onde está escrito 'Floresta Fechada' agora), e
selecionar a outra entrada (que deve ler 'Floresta Mais Fechada').</p>

<p>A boa nova é que o caminho para a saída está desenhado no chão. Como você
pode ver, o mundo é feito de vários corredores, com baggles no chão. Depois
de cada corredor, você deve virar à esquerda se o corredor tiver três
baggels ou mais, e virar a direita se tiver apenas 2 ou menos baggles.</p>

<p>Você deve contar exatamente 5 células por corredor. Aquela com a intersecção
conta como a última do corredor anterior, não como a primeira depois de você
virar. </p>     

<p>Logo, a forma geral de seu código deve ser algo como "enquanto não encontrar
a saída, pegue o próximo corredor para decidir se vira à esqueda ou à
direita na próxima intersecção". Você pode determinar se você está na célula
de saída (que é laranja) com o método <code>saídaAlcançada()</code>
fornecido.</p>

<p>Para entrar em um corredor, você tem simplesmente que ir de uma intersecção
para a outra enquanto conta os baggles que vê em seu caminho. O método
"<code>cruzamento()</code>" diz se seu buggle está ou não numa
intersecção. A complexidade extra é que no começo de um corredor, você está
obviamente numa intersecção, mas você ainda precisa se mover.
[!java|scala|c]Para isto, a forma mais fácil é usar um loop <code>do /
while</code> (faça / enquanto) ao invés de um loop <code>while</code>
(enquanto) normal para se mover até a próxima intersecção.[/!] [!python]Para
isto, use uma variável extra indicando quando você já entrou no corredor,
como segue. Isto vai garantir que você execute o corpo do loop pelo menos
uma vez (quando o <code>primeiraVez</code> for verdadeiro) antes de nós
usarmos realmente o valor retornado pelo <code>cruzamento()</code> para
determinar se continuamos ou não.[/!]</p>

[!python]
<pre>primeiraVez = True
while primeiraVez or not cruzamento():
  primeiraVez = False
  (corpo do loop)
</pre>
[/!] 

<p><div class="tip" id="tip-1" alt="Eu não consigo imaginar como contar os baggles que eu vejo.">
Você precisa de uma variável que é inicializada em 0, e incrementada cada
vez que você vê um baggle no chão. Uma variável usada desta forma é
frequentemente chamada de <i>contador</i>.<br/><br/>
Não esqueça de resetar seu contador para 0 no começo de cada corredor! 
</div></p>

<p>Ah, e quando chegar na saída, não esqueça de dar um passo a mais para sair
de fato do labirinto!</p> 
