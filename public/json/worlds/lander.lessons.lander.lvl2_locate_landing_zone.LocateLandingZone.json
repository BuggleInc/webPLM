JsUndefined('initialWorlds' is undefined on object: {"id":"lander.lessons.lander.lvl2_locate_landing_zone.LocateLandingZone","instructions":"\r\n<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->\r\n<h2>Repérer une zone plate</h2>\r\n\r\n<p>Après 200 jours de voyage intersidéral à manger des céréales, vous êtes\r\nenfin parvenu à la planète rouge. Il est enfin temps de se poser !</p>\r\n\r\n<p>Le module est en pilote automatique, et vous n'avez qu'à regarder autour de\r\nvous pour sélectionner une zone d'alunissage. Vous devez vous poser sur\r\n<b>une zone plate</b> si vous ne voulez pas vous scratcher. Vous indiquez au\r\npilote automatique où se poser en modifiant la fonction\r\n<code>getLandingZone</code> de façon à ce qu'elle retourne un\r\nSegment représentant la zone de votre choix.\r\n\r\n<p>Un Segment est composé de deux <code>Point</code>s, chacun composé de deux\r\ndoubles. On construit un nouveau segment de la façon suivante :\r\n<code>Segment(Point debut, Point\r\nfin)</code>. Pour créer de nouveaux points, il faut\r\nutiliser le constructeur <code>Point(double x,\r\ndouble y)</code>. Les coordonnées d'un point\r\nsont accessibles grâce à ses méthodes <code>double\r\nx()</code> et <code>double\r\ny()</code>.</p> \r\n\r\n<p>Pour déterminer la zone cible, vous devez appeler\r\n<code>List&lt;Point&gt; getSol()</code>,\r\nqui retourne les points qui composent la surface sous la forme d'une list de\r\n<code>Point</code> .</p>\r\n\r\n<p>Une dernière chose : votre fonction doit retourner une zone valide dans\r\ntoutes les situations, pas seulement celle que l'on voit en ce moment. C'est\r\nque votre code sera utilisé dans ce cas, mais également dans la\r\nconfiguration que nous avions dans l'exercice précédent. Comme d'habitude,\r\nvous pouvez voir les autres mondes en les sélectionnant dans le combobox au\r\ndessus de la vue du monde.</p>\r\n\r\n<p>Bon alunissage ! N'oubliez pas de mettre votre combinaison spatiale en\r\nsortant.</p>\r\n","code":"public Segment getLandingZone() {\r\n  /* return new Segment(new Point(0,0), new Point(0,0)); */\r\n}\r\n","selectedWorldID":"Challenging Terrain, Simple Configuration","api":"\r\n<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->\r\n<h2>Alunisseur</h2>\r\n\r\n<p>Dans cet univers, vous contrôlez un module d'alunissage. À chaque pas de la\r\nsimulation, vous avez accès à la position du module, sa vitesse, son angle\r\net la poussée de son moteur. Vous devez alors décider de l'angle et de la\r\npoussée pour l'étape suivante. </p>\r\n\r\n<h2>Fonctions fournies</h2>\r\n\r\n<pre>double getX()\r\ndouble getY()</pre>\r\nRetourne la position en X et Y du module d'alunissage.\r\n<pre>double getVitesseX()\r\ndouble getVitesseY()</pre>\r\nObtenir les vitesses horizontale et verticale du module.\r\n\r\n<pre>double getAngle()\r\nvoid setAngleDesire(double angle)</pre>\r\nRetourne ou fixe l'angle du module d'alunissage.<br/>\r\nUn angle de O° dénote une position verticale, avec le sommet du module\r\ndirigé vers le haut. C'est l'angle avec lequel vous devez vous poser. Un\r\nangle positif indique que le module penche vers la gauche tandis qu'un angle\r\nnégatif indique au contraire qu'il penche à droite. Il est impossible de se\r\npencher à plus de ±90°, et on ne peut pas pencher le module de plus de ±5°\r\nen une fois.\r\n\r\n<pre>int getPoussee()\r\nvoid setPousseeDesiree(int poussée)</pre>\r\nRetourne ou fixe la poussée du module. <br/>Vous ne pouvez incrémenter ou décrémenter la poussée que d'une unité à\r\nchaque fois. Si votre poussée actuelle est de 2 et que vous demandez une\r\npoussée de 4, vous n'obtiendrez que 3 au prochain pas de temps. Si vous\r\ndemandez moins que 0 (ou plus que 4), tout se passera comme si vous\r\ndemandiez 0 (ou 4).\r\n\r\n<pre>int getFuel()</pre>\r\nObtient la quantité de fuel restant dans le réservoir. À chaque pas de\r\nsimulation, le module consomme entre 0 et 4 unités de fuel, en fonction de\r\nsa poussée. Une fois que vous avez utilisé tout votre carburant, vous êtes\r\nen chute libre alors prenez garde !\r\n\r\n<pre>List&lt;Point&gt; getSol()[! scala]:List[Point][/!]</pre>\r\nObtenir les points du sol de gauche à droite. Vous pouvez\r\nretrouver les coordonnées X et Y de chaque point avec les méthodes\r\ncorrespondantes de votre point : <code>p.x()</code> et\r\n<code>p.y()</code>. \r\n","programmingLanguages":[{"lang":"Java","icon":"/img/lang_java.png"},{"lang":"Scala","icon":"/img/lang_scala.png"},{"lang":"Python","icon":"/img/lang_python.png"}],"currentProgrammingLanguage":"Java","toolbox":null,"exception":"nonImplementedWorldException"})