{
  "id" : "recursion.cons.concat.Concat",
  "name" : "Concat",
  "tabName" : "Concat",
  "defaultSourceFiles" : {
    "Java" : {
      "name" : "Concat",
      "body" : "RecList concat(RecList seq1, RecList seq2) {\n}\n",
      "template" : "$package   import plm.universe.bat.BatTest; import plm.universe.cons.ConsEntity; import plm.universe.cons.RecList;  public class Concat extends ConsEntity { \t@Override \tpublic void run(BatTest t) { \t\tRecList parameter1 = RecList.fromArray( (int[]) t.getParameter(0) ); \t\tRecList parameter2 = RecList.fromArray( (int[]) t.getParameter(1) ); \t\tt.setResult( concat( parameter1, parameter2 ) ); \t}  $body } ",
      "offset" : 1,
      "correction" : "$package \n\nimport plm.universe.bat.BatTest;\nimport plm.universe.cons.ConsEntity;\nimport plm.universe.cons.RecList;\n\npublic class Concat extends ConsEntity {\n\n\t@Override\n\tpublic void run(BatTest t) {\n\t\tRecList parameter1 = RecList.fromArray( (int[]) t.getParameter(0) );\n\t\tRecList parameter2 = RecList.fromArray( (int[]) t.getParameter(1) );\n\t\tt.setResult( concat( parameter1, parameter2 ) );\n\t}\n\n\t/* BEGIN TEMPLATE */\n\tRecList concat(RecList seq1, RecList seq2) {\n\t\t/* BEGIN SOLUTION */\n\t\t\n\t\tRecList A = null;\n\t\tRecList B = seq1;\n\t\twhile (B != null) {\n\t\t\tA = new RecList(B.head, A);\n\t\t\tB = B.tail;\n\t\t}\n\t\t\n\t\tB = seq2;\n\t\twhile (A != null) {\n\t\t\tB = new RecList(A.head, B);\n\t\t\tA = A.tail;\n\t\t}\n\t\treturn B;\n\t\t/* END SOLUTION */\n\t}\n\t/* END TEMPLATE */\n}\n",
      "error" : "Error"
    },
    "Scala" : {
      "name" : "Concat",
      "body" : "def concat(l1:List[Int], l2:List[Int]): List[Int] = {\n}\n",
      "template" : "$package \n\nimport plm.universe.bat.BatTest\nimport plm.universe.cons.RecList\nimport plm.universe.cons.ConsEntity\n\nclass Concat extends ConsEntity {\n  override def run(t: BatTest) {\n    val parameter1: List[Int] = RecList.fromArraytoScalaList(t.getParameter(0).asInstanceOf[Array[Int]])\n    val parameter2: List[Int] = RecList.fromArraytoScalaList(t.getParameter(1).asInstanceOf[Array[Int]])  \n    t.setResult( concat(parameter1, parameter2) )\n  }\n\n$body\n}\n",
      "offset" : 12,
      "correction" : "$package \n\nimport plm.universe.bat.BatTest\nimport plm.universe.cons.RecList\nimport plm.universe.cons.ConsEntity\n\nclass Concat extends ConsEntity {\n\n  override def run(t: BatTest) {\n    val parameter1: List[Int] = RecList.fromArraytoScalaList(t.getParameter(0).asInstanceOf[Array[Int]])\n    val parameter2: List[Int] = RecList.fromArraytoScalaList(t.getParameter(1).asInstanceOf[Array[Int]])  \n    t.setResult( concat(parameter1, parameter2) )\n  }\n\n  /* BEGIN TEMPLATE */\n  def concat(l1:List[Int], l2:List[Int]): List[Int] = {\n  /* BEGIN SOLUTION */\n    reverse_helper(  reverse_helper(l1, Nil), l2  )\n  }\n  def reverse_helper(todo:List[Int], done:List[Int]):List[Int] = {\n    if (todo == Nil) {\n      done\n    } else {\n      reverse_helper(todo.tail, todo.head::done)\n    }\n  /* END SOLUTION */\n  }\n  /* END TEMPLATE */\n}\n",
      "error" : "Error"
    },
    "Python" : {
      "name" : "Concat",
      "body" : "def reverse(list):\n",
      "template" : "$body\n",
      "offset" : 1,
      "correction" : "# BEGIN TEMPLATE\ndef reverse(list):\n# BEGIN SOLUTION\n  A = None\n  B = list\n  while B != None:\n    A = new RecList(B.head, A)\n    B = B.tail\n  return A\n# END SOLUTION\n# END TEMPLATE\n",
      "error" : "Error"
    }
  },
  "helps" : {
    "pt" : "<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->\n<h1>ConsWorld</h1>\n\n<p>This world allows you to experiment with the recursive lists, as\nthey were first introduced in Lisp. It is very similar to the BatWorld,\nbut you are supposed to write recursive functions working on \n[!python|java]recursive strings. Since [!thelang] does not provide\nsuch a construct natively, the ConsWorld defines recursive lists of\ntype <code>RecList</code>.[/!]\n[!scala]lists of integers (<code>List[Int]</code>).[/!]</p>\n\n<p>Any given such list is either the empty list \n(noted <code>[!scala]Nil[/!][!java]null[/!][!python]None[/!]</code>),\nor an integer followed by a list. If a list is not empty, you can\nretrieve its first integer with <code>list.head</code> and the list\ncontaining its other parameters with <code>list.tail</code>. Of\ncourse, the empty list has no head nor the tail, so trying to access\nthese elements will result in an (unpleasant) error message.</p>\n\n<p>To build your own list, you need to concatenate a head and a tail\nas follows: \n[!java|python]<code>cons(head, tail)</code>[/!]\n[!scala]<code>head::tail</code> Note that <code>::</code> is a generic\noperator in Scala to build lists.[/!]</p>\n\n<p>So, in summary, you can solve every exercises of this lesson with\nthe following constructs.</p>\n\n<ul>\n<li><b>The empty list:</b> <pre>[!java]null[/!][!scala]Nil[/!][!python]None[/!]</pre></li>\n<li><b>Get the first element of <code>l</code></b> <pre>l.head</pre></li>\n<li><b>Get the rest of the list</b>, when the first element is removed: <pre>l.tail</pre></li>\n<li><b>Build a list</b> from a <code>value</code> and a <code>list</code>: \n[!java|python]<pre>cons(value, list)</pre>[/!]\n[!scala]<pre>value::list</pre>[/!]</li>\n</ul>\n",
    "en" : "<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->\n<h1>ConsWorld</h1>\n\n<p>This world allows you to experiment with the recursive lists, as\nthey were first introduced in Lisp. It is very similar to the BatWorld,\nbut you are supposed to write recursive functions working on \n[!python|java]recursive strings. Since [!thelang] does not provide\nsuch a construct natively, the ConsWorld defines recursive lists of\ntype <code>RecList</code>.[/!]\n[!scala]lists of integers (<code>List[Int]</code>).[/!]</p>\n\n<p>Any given such list is either the empty list \n(noted <code>[!scala]Nil[/!][!java]null[/!][!python]None[/!]</code>),\nor an integer followed by a list. If a list is not empty, you can\nretrieve its first integer with <code>list.head</code> and the list\ncontaining its other parameters with <code>list.tail</code>. Of\ncourse, the empty list has no head nor the tail, so trying to access\nthese elements will result in an (unpleasant) error message.</p>\n\n<p>To build your own list, you need to concatenate a head and a tail\nas follows: \n[!java|python]<code>cons(head, tail)</code>[/!]\n[!scala]<code>head::tail</code> Note that <code>::</code> is a generic\noperator in Scala to build lists.[/!]</p>\n\n<p>So, in summary, you can solve every exercises of this lesson with\nthe following constructs.</p>\n\n<ul>\n<li><b>The empty list:</b> <pre>[!java]null[/!][!scala]Nil[/!][!python]None[/!]</pre></li>\n<li><b>Get the first element of <code>l</code></b> <pre>l.head</pre></li>\n<li><b>Get the rest of the list</b>, when the first element is removed: <pre>l.tail</pre></li>\n<li><b>Build a list</b> from a <code>value</code> and a <code>list</code>: \n[!java|python]<pre>cons(value, list)</pre>[/!]\n[!scala]<pre>value::list</pre>[/!]</li>\n</ul>\n",
    "fr" : "\n<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->\n<h1>Monde des listes récursives</h1>\n\n<p>Ce monde vous permettra d'expérimenter avec les listes récursives, telles\nqu'elles ont été définies en Lisp à l'origine. Ce monde est assez similaire\nau BatWorld, mais vous êtes supposé écrire des fonctions récursives agissant\nsur des [!python|java]listes récursives. Comme [!thelang] ne propose rien de\ntel en natif, ce monde défini un nouveau type nommé <code>RecList</code>\npour cela.[/!] [!scala]listes d'entiers (<code>List[Int]</code>).[/!]</p>\n\n<p>Une telle liste peut être soit la liste vide (notée\n<code>[!scala]Nil[/!][!java]null[/!][!python]None[/!]</code>), soit un\nentier suivi d'une liste. Si une liste n'est pas vide, vous pouvez retrouver\nson premier entier avec <code>list.head</code>. On dit qu'on extrait alors\nla tête de la liste.La liste contenant ses autres éléments (tous sauf la\ntête) peut être retrouvée avec <code>list.tail</code>. On dit qu'on extrait\nla suite de la liste.Bien entendu, la liste vide n'a ni tête ni suite, et\nvous ne devriez pas tenter d'accéder à ces éléments sous peine d'obtenir un\nmessage d'erreur (particulièrement déplaisant).</p>\n\n<p>Pour construire votre propre liste, vous devez concaténer une tête et une\nsuite comme suit : [!java|python]<code>cons(tête, suite)</code>[/!]\n[!scala]<code>tête::suite</code>. Il se trouve que <code>::</code> est un\nopérateur générique du langage Scala pour construire des listes.[/!]</p>\n\n<p>En résumé, vous pouvez résoudre tous les exercices de cette leçon avec les\nconstructions suivantes :</p>\n\n<ul>\n<li><b>La liste vide:</b> <pre>[!java|c]null[/!][!scala]Nil[/!][!python]None[/!]</pre></li>\n<li><b>Obtenir le premier élément de <code>l</code></b> <pre>l.head</pre></li>\n<li><b>Obtenir la suite de la liste</b>, privée de son premier élément: <pre>l.tail</pre></li>\n<li><b>Construire une liste</b> à partir d'une <code>valeur</code> et d'une\n<code>liste</code>: [!java|python]<pre>cons(valeur, liste)</pre>[/!] [!scala]<pre>valeur::liste</pre>[/!]</li>\n</ul>\n"
  },
  "initialWorlds" : [ {
    "type" : "plm.universe.cons.ConsWorld",
    "@jsonId" : 1,
    "name" : "concat",
    "batTests" : [ {
      "funName" : "concat",
      "visible" : true,
      "parameters" : [ [ "[I", [ 1, 2, 3 ] ], [ "[I", [ 11, 12, 13 ] ] ],
      "result" : null,
      "correct" : false,
      "answered" : false,
      "objectiveTest" : false
    }, {
      "funName" : "concat",
      "visible" : true,
      "parameters" : [ [ "[I", [ 1, 2, 3 ] ], [ "[I", [ 1, 1, 1 ] ] ],
      "result" : null,
      "correct" : false,
      "answered" : false,
      "objectiveTest" : false
    }, {
      "funName" : "concat",
      "visible" : true,
      "parameters" : [ [ "[I", [ 1, 2, 3 ] ], [ "[I", [ ] ] ],
      "result" : null,
      "correct" : false,
      "answered" : false,
      "objectiveTest" : false
    }, {
      "funName" : "concat",
      "visible" : true,
      "parameters" : [ [ "[I", [ 1, 2, 1, 3 ] ], [ "[I", [ 64, 36 ] ] ],
      "result" : null,
      "correct" : false,
      "answered" : false,
      "objectiveTest" : false
    }, {
      "funName" : "concat",
      "visible" : false,
      "parameters" : [ [ "[I", [ 2, 4, 6, 8, 10 ] ], [ "[I", [ 72, 35 ] ] ],
      "result" : null,
      "correct" : false,
      "answered" : false,
      "objectiveTest" : false
    }, {
      "funName" : "concat",
      "visible" : false,
      "parameters" : [ [ "[I", [ ] ], [ "[I", [ 3, 5, 8 ] ] ],
      "result" : null,
      "correct" : false,
      "answered" : false,
      "objectiveTest" : false
    }, {
      "funName" : "concat",
      "visible" : false,
      "parameters" : [ [ "[I", [ ] ], [ "[I", [ ] ] ],
      "result" : null,
      "correct" : false,
      "answered" : false,
      "objectiveTest" : false
    }, {
      "funName" : "concat",
      "visible" : false,
      "parameters" : [ [ "[I", [ -2, -4, -6, -8, -10 ] ], [ "[I", [ 2, 4, 6, 8, 10 ] ] ],
      "result" : null,
      "correct" : false,
      "answered" : false,
      "objectiveTest" : false
    } ],
    "entities" : [ {
      "type" : "plm.universe.cons.ConsEntity",
      "name" : "concat",
      "world" : 1,
      "inited" : false
    } ],
    "steps" : [ ],
    "about" : "<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->\n<h1>ConsWorld</h1>\n\n<p>This world allows you to experiment with the recursive lists, as\nthey were first introduced in Lisp. It is very similar to the BatWorld,\nbut you are supposed to write recursive functions working on \nrecursive strings. Since Java does not provide\nsuch a construct natively, the ConsWorld defines recursive lists of\ntype <code>RecList</code>.\n</p>\n\n<p>Any given such list is either the empty list \n(noted <code>null</code>),\nor an integer followed by a list. If a list is not empty, you can\nretrieve its first integer with <code>list.head</code> and the list\ncontaining its other parameters with <code>list.tail</code>. Of\ncourse, the empty list has no head nor the tail, so trying to access\nthese elements will result in an (unpleasant) error message.</p>\n\n<p>To build your own list, you need to concatenate a head and a tail\nas follows: \n<code>cons(head, tail)</code>\n</p>\n\n<p>So, in summary, you can solve every exercises of this lesson with\nthe following constructs.</p>\n\n<ul>\n<li><b>The empty list:</b> <pre>null</pre></li>\n<li><b>Get the first element of <code>l</code></b> <pre>l.head</pre></li>\n<li><b>Get the rest of the list</b>, when the first element is removed: <pre>l.tail</pre></li>\n<li><b>Build a list</b> from a <code>value</code> and a <code>list</code>: \n<pre>cons(value, list)</pre>\n</li>\n</ul>\n",
    "parameters" : null
  } ],
  "answerWorlds" : [ {
    "type" : "plm.universe.cons.ConsWorld",
    "@jsonId" : 2,
    "name" : "concat",
    "batTests" : [ {
      "funName" : "concat",
      "visible" : true,
      "parameters" : [ [ "[I", [ 1, 2, 3 ] ], [ "[I", [ 11, 12, 13 ] ] ],
      "result" : {
        "type" : "plm.universe.cons.RecList",
        "list" : [ 1, 2, 3, 11, 12, 13 ]
      },
      "correct" : false,
      "answered" : true,
      "objectiveTest" : false
    }, {
      "funName" : "concat",
      "visible" : true,
      "parameters" : [ [ "[I", [ 1, 2, 3 ] ], [ "[I", [ 1, 1, 1 ] ] ],
      "result" : {
        "type" : "plm.universe.cons.RecList",
        "list" : [ 1, 2, 3, 1, 1, 1 ]
      },
      "correct" : false,
      "answered" : true,
      "objectiveTest" : false
    }, {
      "funName" : "concat",
      "visible" : true,
      "parameters" : [ [ "[I", [ 1, 2, 3 ] ], [ "[I", [ ] ] ],
      "result" : {
        "type" : "plm.universe.cons.RecList",
        "list" : [ 1, 2, 3 ]
      },
      "correct" : false,
      "answered" : true,
      "objectiveTest" : false
    }, {
      "funName" : "concat",
      "visible" : true,
      "parameters" : [ [ "[I", [ 1, 2, 1, 3 ] ], [ "[I", [ 64, 36 ] ] ],
      "result" : {
        "type" : "plm.universe.cons.RecList",
        "list" : [ 1, 2, 1, 3, 64, 36 ]
      },
      "correct" : false,
      "answered" : true,
      "objectiveTest" : false
    }, {
      "funName" : "concat",
      "visible" : false,
      "parameters" : [ [ "[I", [ 2, 4, 6, 8, 10 ] ], [ "[I", [ 72, 35 ] ] ],
      "result" : {
        "type" : "plm.universe.cons.RecList",
        "list" : [ 2, 4, 6, 8, 10, 72, 35 ]
      },
      "correct" : false,
      "answered" : true,
      "objectiveTest" : false
    }, {
      "funName" : "concat",
      "visible" : false,
      "parameters" : [ [ "[I", [ ] ], [ "[I", [ 3, 5, 8 ] ] ],
      "result" : {
        "type" : "plm.universe.cons.RecList",
        "list" : [ 3, 5, 8 ]
      },
      "correct" : false,
      "answered" : true,
      "objectiveTest" : false
    }, {
      "funName" : "concat",
      "visible" : false,
      "parameters" : [ [ "[I", [ ] ], [ "[I", [ ] ] ],
      "result" : null,
      "correct" : false,
      "answered" : true,
      "objectiveTest" : false
    }, {
      "funName" : "concat",
      "visible" : false,
      "parameters" : [ [ "[I", [ -2, -4, -6, -8, -10 ] ], [ "[I", [ 2, 4, 6, 8, 10 ] ] ],
      "result" : {
        "type" : "plm.universe.cons.RecList",
        "list" : [ -2, -4, -6, -8, -10, 2, 4, 6, 8, 10 ]
      },
      "correct" : false,
      "answered" : true,
      "objectiveTest" : false
    } ],
    "entities" : [ {
      "type" : "plm.universe.cons.ConsEntity",
      "name" : "concat",
      "world" : 2,
      "inited" : true
    } ],
    "steps" : [ [ {
      "type" : "plm.universe.bat.operations.SetResult",
      "@jsonId" : 3,
      "index" : 0,
      "result" : {
        "type" : "plm.universe.cons.RecList",
        "list" : [ 1, 2, 3, 11, 12, 13 ]
      },
      "name" : "setResult"
    } ], [ {
      "type" : "plm.universe.bat.operations.SetResult",
      "@jsonId" : 4,
      "index" : 1,
      "result" : {
        "type" : "plm.universe.cons.RecList",
        "list" : [ 1, 2, 3, 1, 1, 1 ]
      },
      "name" : "setResult"
    } ], [ {
      "type" : "plm.universe.bat.operations.SetResult",
      "@jsonId" : 5,
      "index" : 2,
      "result" : {
        "type" : "plm.universe.cons.RecList",
        "list" : [ 1, 2, 3 ]
      },
      "name" : "setResult"
    } ], [ {
      "type" : "plm.universe.bat.operations.SetResult",
      "@jsonId" : 6,
      "index" : 3,
      "result" : {
        "type" : "plm.universe.cons.RecList",
        "list" : [ 1, 2, 1, 3, 64, 36 ]
      },
      "name" : "setResult"
    } ], [ {
      "type" : "plm.universe.bat.operations.SetResult",
      "@jsonId" : 7,
      "index" : 4,
      "result" : {
        "type" : "plm.universe.cons.RecList",
        "list" : [ 2, 4, 6, 8, 10, 72, 35 ]
      },
      "name" : "setResult"
    } ], [ {
      "type" : "plm.universe.bat.operations.SetResult",
      "@jsonId" : 8,
      "index" : 5,
      "result" : {
        "type" : "plm.universe.cons.RecList",
        "list" : [ 3, 5, 8 ]
      },
      "name" : "setResult"
    } ], [ {
      "type" : "plm.universe.bat.operations.SetResult",
      "@jsonId" : 9,
      "index" : 6,
      "result" : null,
      "name" : "setResult"
    } ], [ {
      "type" : "plm.universe.bat.operations.SetResult",
      "@jsonId" : 10,
      "index" : 7,
      "result" : {
        "type" : "plm.universe.cons.RecList",
        "list" : [ -2, -4, -6, -8, -10, 2, 4, 6, 8, 10 ]
      },
      "name" : "setResult"
    } ] ],
    "about" : "<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->\n<h1>ConsWorld</h1>\n\n<p>This world allows you to experiment with the recursive lists, as\nthey were first introduced in Lisp. It is very similar to the BatWorld,\nbut you are supposed to write recursive functions working on \nrecursive strings. Since Java does not provide\nsuch a construct natively, the ConsWorld defines recursive lists of\ntype <code>RecList</code>.\n</p>\n\n<p>Any given such list is either the empty list \n(noted <code>null</code>),\nor an integer followed by a list. If a list is not empty, you can\nretrieve its first integer with <code>list.head</code> and the list\ncontaining its other parameters with <code>list.tail</code>. Of\ncourse, the empty list has no head nor the tail, so trying to access\nthese elements will result in an (unpleasant) error message.</p>\n\n<p>To build your own list, you need to concatenate a head and a tail\nas follows: \n<code>cons(head, tail)</code>\n</p>\n\n<p>So, in summary, you can solve every exercises of this lesson with\nthe following constructs.</p>\n\n<ul>\n<li><b>The empty list:</b> <pre>null</pre></li>\n<li><b>Get the first element of <code>l</code></b> <pre>l.head</pre></li>\n<li><b>Get the rest of the list</b>, when the first element is removed: <pre>l.tail</pre></li>\n<li><b>Build a list</b> from a <code>value</code> and a <code>list</code>: \n<pre>cons(value, list)</pre>\n</li>\n</ul>\n",
    "parameters" : null
  } ],
  "instructions" : {
    "pt" : "\n<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->\n<h1>Concat</h1>\nDadas duas [!scala]List[Int][/!][!java|python]recursive list[/!]\n<code>l1</code> e <code>l2</code>, retorna uma nova lista com todos os\nelementos de <code>l1</code> seguidos de todos os elementos de\n<code>l2</code>. \n\n<p>Sua solução deve ser linear no tempo, mas você provavelmente precisa definir\nvárias funções para alcançar esta complexidade.</p>\n\n<tips data-tipid=\"tip-1\" data-title=\"Eu não posso fazer isto em tempo linear\">\nVocê precisa modificar <code>l1</code> antes de forma que os cálculos em\ncada passo da recursão sejam em tempo constante.\n</tips>\n",
    "en" : "<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->\n<h1>Concat</h1>\nGiven two [!scala]List[Int][/!][!java|python]recursive list[/!] <code>l1</code> and <code>l2</code>, \nreturn a new list with all elements of <code>l1</code> followed by the elements of <code>l2</code>. \n\n<p>Your solution should be linear in time, but you will probably need to define several functions to achieve that complexity.</p>\n\n<tips data-tipid=\"tip-1\" data-title=\"I cannot do it in linear time\">\nYou need to modify <code>l1</code> beforehand so that the computations at each step of the recursion are in constant time.\n</tips>\n",
    "fr" : "\n<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->\n<h1>Concaténation</h1>\nÉtant donnée deux [!scala]List[Int][/!][!java|python]listes récursives[/!]\n<code>l1</code> et <code>l2</code>, retournez la liste constituée de tous\nles éléments de <code>l1</code> suivis de tous les éléments de\n<code>l2</code>. \n\n<p>Votre solution devrait être linéaire en temps, mais vous aurez probablement\nbesoin de définir plusieurs fonctions pour atteindre cette complexité.</p>\n\n<tips data-tipid=\"tip-1\" data-title=\"Je n'arrive pas à le faire en temps linéaire\">\nIl faut modifier <code>l1</code> au préalable pour s'assurer que chaque\nétape récursive soit en temps constant.\n</tips>\n"
  }
}