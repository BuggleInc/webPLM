{
  "id" : "conditions.Conditions",
  "name" : "Conditions",
  "tabName" : "Program",
  "defaultSourceFiles" : {
    "Java" : {
      "name" : "Conditions",
      "body" : "",
      "template" : "$package   import plm.universe.bugglequest.SimpleBuggle;  public class Conditions extends SimpleBuggle {\t@Override \tpublic void run() {  $body \t} } ",
      "offset" : 1,
      "correction" : "$package \n\nimport plm.universe.bugglequest.AbstractBuggle;\n\npublic class Conditions extends AbstractBuggle {\n\t@Override\n\tpublic void run() { \n\t\t/* BEGIN TEMPLATE */\n\t\t/* BEGIN SOLUTION */\n\t\tif (isFacingWall())\n\t\t\tbackward();\n\t\telse\n\t\t\tforward();\n\t\t/* END SOLUTION */\n\t\t/* END TEMPLATE */\n\t}\n}\n",
      "error" : "Error"
    },
    "Scala" : {
      "name" : "Conditions",
      "body" : "",
      "template" : "$package \n\nimport plm.universe.bugglequest.SimpleBuggle;\n\nclass Conditions extends SimpleBuggle {\toverride def run() { \n$body\n\t}\n}\n",
      "offset" : 5,
      "correction" : "$package \n\nimport plm.universe.bugglequest.AbstractBuggle;\n\nclass Conditions extends AbstractBuggle {\n\toverride def run() { \n\t\t/* BEGIN SOLUTION */\n\t\tif (isFacingWall())\n\t\t\tbackward();\n\t\telse\n\t\t\tforward();\n\t\t/* END SOLUTION */\n\t}\n}\n",
      "error" : "Error"
    },
    "Python" : {
      "name" : "Conditions",
      "body" : "",
      "template" : "$body\n",
      "offset" : 1,
      "correction" : "# BEGIN SOLUTION\nif isFacingWall():\n    backward()\nelse:\n    forward()    \n# END SOLUTION\n",
      "error" : "Error"
    }
  },
  "helps" : {
    "pt" : "<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->\n<h1>BuggleWorld</h1>\nThis world was invented by Lyn Turbak, at Wellesley College. It is full of\nBuggles, little animals understanding simple orders, and offers numerous\npossibilities of interaction with the world: taking or dropping objects,\npaint the ground, hit walls, etc.\n\n<h2>Methods understood by buggles</h2>\n<table border=1>\n<tr><td colspan=2 align=center><b>Moving</b><br/> (See also the note on exceptions, below)</td></tr>\n  <tr><td><b>Turn left<br/>Turn right<br/>Turn back<br/>Moving forward<br/>Moving back</b></td>\n      <td>[!java|c]void [/!]left()<br/>\n          [!java|c]void [/!]right()<br/>\n          [!java|c]void [/!]back()<br/>\n          [!java|c]void [/!][!python|java|scala]forward()[/!][!c]stepForward()[/!] or [!java|c]void [/!]forward([!java|c]int [/!]steps[!scala]:Int[/!])<br/>\n          [!java|c]void [/!][!python|java|scala]backward()[/!][!c]stepBackward()[/!] or [!java]void [/!]backward([!java|c]int [/!]steps[!scala]:Int[/!])<br/></td></tr>\n  <tr><td><b>Get X coordinate<br/>Get Y coordinate<br/>Set X coordinate<br/>Set Y coordinate<br/>Set position</b></td>\n      <td>[!java|c]int [/!]getX()[!scala]:Int[/!]<br/>\n          [!java|c]int [/!]getY()[!scala]:Int[/!]<br/>\n          [!java|c]void [/!]setX([!java|c]int [/!]x[!scala]:Int[/!])<br/>\n          [!java|c]void [/!]setY([!java|c]int [/!]y[!scala]:Int[/!])<br/>\n          [!java|c]void [/!]setPos([!java|c]int [/!]x[!scala]:Int[/!], [!java|c]int [/!]y[!scala]:Int[/!])</td></tr>\n<tr><td colspan=2>Note that the point (0,0) is on the top left corner, as it is often the case in Computer Science.</td></tr>\n\n<tr><td colspan=2 align=center><b>Information on the buggle</b></td></tr>\n  <tr><td><b>Get the color of the body<br/>Set the color of the body</b></td>\n      <td>[!java|c]Color [/!]getBodyColor()[!scala]:Color[/!]<br/>\n          [!java|c]void [/!]setBodyColor([!java|c]Color [/!]c[!scala]:Color[/!])</td></tr>\t\t\t\t\n  <tr><td><b>Look for a wall forward<br/>Look for a wall backward</b></td>\n      <td>[!java]boolean [/!][!c]int [/!]isFacingWall()[!scala]:Boolean[/!]<br/>\n          [!java]boolean [/!][!c]int [/!]isBackingWall()[!scala]:Boolean[/!]</td></tr>\t\t\t\t\n  <tr><td><b>Get heading<br/>Set heading</b><br/>valid directions are:</td>\n      <td>[!java|c]Direction [/!]getDirection()[!scala]:Direction[/!]<br/>\n          [!java|c]void [/!]setDirection([!java|c]Direction [/!]dir[!scala]:Direction[/!])<br/>\n          [!scala|java|python]Direction.[/!]NORTH, [!scala|java|python]Direction.[/!]EAST, [!scala|java|python]Direction.[/!]SOUTH and [!scala|java|python]Direction.[/!]WEST</td></tr>\n  <tr><td>Check whether the buggle is currently <b>selected in the interface</b></td>\n      <td>[!java]boolean [/!][!c]int [/!]isSelected()[!scala]:Boolean[/!]</td></tr>\n \n<tr><td colspan=2 align=center><b>About the brush</b></td></tr>\n  <tr><td><b>Brush down<br/>Brush up<br/>Get brush position</b></td>\n      <td>[!java|c]void [/!]brushUp()<br/>\n          [!java|c]void [/!]brushDown()<br/>\n          [!java]boolean [/!][!c]int [/!]isBrushDown()[!scala]:Boolean[/!]</td></tr>\n  <tr><td><b>Change the brush color<br/>Get the color of the brush</b></td>\n      <td>[!java|c]void [/!]setBrushColor([!java|c]Color [/!]c[!scala]:Color[/!])<br/>\n          [!java|c]Color [/!]getBrushColor()[!scala]:Color[/!]</td></tr>\n\n<tr><td colspan=2 align=center><b>Interacting with the world</b></td></tr>\n  <tr><td><b>Get the color of the ground</b></td>\n      <td>[!java|c]Color [/!]getGroundColor()[!scala]:Color[/!]</td></tr>\n\n  <tr><td><b>Look for a baggle on the ground<br/>Look for a baggle in bag<br/>Pickup a baggle<br/>Drop a baggle</b><br/>\n      (see the note on exceptions)</td>\n      <td>[!java]boolean [/!][!c]int [/!]isOverBaggle()[!scala]:Boolean[/!]<br/>\n          [!java]boolean [/!][!c]int [/!]isCarryingBaggle()[!scala]:Boolean[/!]<br/>\n          [!java]void [/!]pickupBaggle()<br/>\n          [!java]void [/!]dropBaggle()<br/>\n          &nbsp;</td></tr>\n\n  <tr><td><b>Look for a message<br/>Add a message<br/>Read the message<br/>Erase the message</b></td>\n      <td>[!java]boolean [/!][!c]int [/!]isOverMessage()[!scala]:Boolean[/!]<br/>\n          [!java]void [/!]writeMessage([!java]String [/!][!c]char* [/!]msg[!scala]:String[/!])<br/>\n          [!java]String [/!][!c]char* [/!]readMessage()[!scala]:String[/!]<br/>\n          [!java]void [/!]clearMessage()</td></tr>\n</table>\n\n<h2>Valid colors</h2>\n<table border=1>\n<tr><td>Name</td><td>Color</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]black</td>    <td BGCOLOR=\"#000000\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]blue</td>     <td BGCOLOR=\"#0000FF\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]cyan</td>     <td BGCOLOR=\"#00FFFF\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]darkGray</td> <td BGCOLOR=\"#404040\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]gray</td>     <td BGCOLOR=\"#808080\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]green</td>    <td BGCOLOR=\"#00FF00\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]lightGray</td><td BGCOLOR=\"#C0C0C0\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]magenta</td>  <td BGCOLOR=\"#FF00FF\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]orange</td>   <td BGCOLOR=\"#FFC800\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]pink</td>     <td BGCOLOR=\"#FFAFAF\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]red</td>      <td BGCOLOR=\"#FF0000\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]white</td>    <td BGCOLOR=\"#FFFFFF\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]yellow</td>   <td BGCOLOR=\"#FFFF00\">&nbsp;</td></tr>\n</table>\n\n<h2>Note on exceptions</h2>\nRegular buggles throw a BuggleWallException exception if you ask them to\ntraverse a wall.  They throw a NoBaggleUnderBuggleException exception if you\nask them to pickup a baggle from an empty cell, or a\nAlreadyHaveBaggleException exception if they already carry a baggle.  Trying\nto drop a baggle on a cell already containing one throws an\nAlreadyHaveBaggleException exception. \nDropping a baggle when you have none throws a DontHaveBaggleException.\n<p>SimpleBuggles (ie, the one used in first exercises) display an error message\non problem so that you don't need to know what an exception is.</p>\n",
    "en" : "<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->\n<h1>BuggleWorld</h1>\nThis world was invented by Lyn Turbak, at Wellesley College. It is full of\nBuggles, little animals understanding simple orders, and offers numerous\npossibilities of interaction with the world: taking or dropping objects,\npaint the ground, hit walls, etc.\n\n<h2>Methods understood by buggles</h2>\n<table border=1>\n<tr><td colspan=2 align=center><b>Moving</b><br/> (See also the note on exceptions, below)</td></tr>\n  <tr><td><b>Turn left<br/>Turn right<br/>Turn back<br/>Moving forward<br/>Moving back</b></td>\n      <td>[!java|c]void [/!]left()<br/>\n          [!java|c]void [/!]right()<br/>\n          [!java|c]void [/!]back()<br/>\n          [!java|c]void [/!][!python|java|scala]forward()[/!][!c]stepForward()[/!] or [!java|c]void [/!]forward([!java|c]int [/!]steps[!scala]:Int[/!])<br/>\n          [!java|c]void [/!][!python|java|scala]backward()[/!][!c]stepBackward()[/!] or [!java]void [/!]backward([!java|c]int [/!]steps[!scala]:Int[/!])<br/></td></tr>\n  <tr><td><b>Get X coordinate<br/>Get Y coordinate<br/>Set X coordinate<br/>Set Y coordinate<br/>Set position</b></td>\n      <td>[!java|c]int [/!]getX()[!scala]:Int[/!]<br/>\n          [!java|c]int [/!]getY()[!scala]:Int[/!]<br/>\n          [!java|c]void [/!]setX([!java|c]int [/!]x[!scala]:Int[/!])<br/>\n          [!java|c]void [/!]setY([!java|c]int [/!]y[!scala]:Int[/!])<br/>\n          [!java|c]void [/!]setPos([!java|c]int [/!]x[!scala]:Int[/!], [!java|c]int [/!]y[!scala]:Int[/!])</td></tr>\n<tr><td colspan=2>Note that the point (0,0) is on the top left corner, as it is often the case in Computer Science.</td></tr>\n\n<tr><td colspan=2 align=center><b>Information on the buggle</b></td></tr>\n  <tr><td><b>Get the color of the body<br/>Set the color of the body</b></td>\n      <td>[!java|c]Color [/!]getBodyColor()[!scala]:Color[/!]<br/>\n          [!java|c]void [/!]setBodyColor([!java|c]Color [/!]c[!scala]:Color[/!])</td></tr>\t\t\t\t\n  <tr><td><b>Look for a wall forward<br/>Look for a wall backward</b></td>\n      <td>[!java]boolean [/!][!c]int [/!]isFacingWall()[!scala]:Boolean[/!]<br/>\n          [!java]boolean [/!][!c]int [/!]isBackingWall()[!scala]:Boolean[/!]</td></tr>\t\t\t\t\n  <tr><td><b>Get heading<br/>Set heading</b><br/>valid directions are:</td>\n      <td>[!java|c]Direction [/!]getDirection()[!scala]:Direction[/!]<br/>\n          [!java|c]void [/!]setDirection([!java|c]Direction [/!]dir[!scala]:Direction[/!])<br/>\n          [!scala|java|python]Direction.[/!]NORTH, [!scala|java|python]Direction.[/!]EAST, [!scala|java|python]Direction.[/!]SOUTH and [!scala|java|python]Direction.[/!]WEST</td></tr>\n  <tr><td>Check whether the buggle is currently <b>selected in the interface</b></td>\n      <td>[!java]boolean [/!][!c]int [/!]isSelected()[!scala]:Boolean[/!]</td></tr>\n \n<tr><td colspan=2 align=center><b>About the brush</b></td></tr>\n  <tr><td><b>Brush down<br/>Brush up<br/>Get brush position</b></td>\n      <td>[!java|c]void [/!]brushUp()<br/>\n          [!java|c]void [/!]brushDown()<br/>\n          [!java]boolean [/!][!c]int [/!]isBrushDown()[!scala]:Boolean[/!]</td></tr>\n  <tr><td><b>Change the brush color<br/>Get the color of the brush</b></td>\n      <td>[!java|c]void [/!]setBrushColor([!java|c]Color [/!]c[!scala]:Color[/!])<br/>\n          [!java|c]Color [/!]getBrushColor()[!scala]:Color[/!]</td></tr>\n\n<tr><td colspan=2 align=center><b>Interacting with the world</b></td></tr>\n  <tr><td><b>Get the color of the ground</b></td>\n      <td>[!java|c]Color [/!]getGroundColor()[!scala]:Color[/!]</td></tr>\n\n  <tr><td><b>Look for a baggle on the ground<br/>Look for a baggle in bag<br/>Pickup a baggle<br/>Drop a baggle</b><br/>\n      (see the note on exceptions)</td>\n      <td>[!java]boolean [/!][!c]int [/!]isOverBaggle()[!scala]:Boolean[/!]<br/>\n          [!java]boolean [/!][!c]int [/!]isCarryingBaggle()[!scala]:Boolean[/!]<br/>\n          [!java]void [/!]pickupBaggle()<br/>\n          [!java]void [/!]dropBaggle()<br/>\n          &nbsp;</td></tr>\n\n  <tr><td><b>Look for a message<br/>Add a message<br/>Read the message<br/>Erase the message</b></td>\n      <td>[!java]boolean [/!][!c]int [/!]isOverMessage()[!scala]:Boolean[/!]<br/>\n          [!java]void [/!]writeMessage([!java]String [/!][!c]char* [/!]msg[!scala]:String[/!])<br/>\n          [!java]String [/!][!c]char* [/!]readMessage()[!scala]:String[/!]<br/>\n          [!java]void [/!]clearMessage()</td></tr>\n</table>\n\n<h2>Valid colors</h2>\n<table border=1>\n<tr><td>Name</td><td>Color</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]black</td>    <td BGCOLOR=\"#000000\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]blue</td>     <td BGCOLOR=\"#0000FF\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]cyan</td>     <td BGCOLOR=\"#00FFFF\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]darkGray</td> <td BGCOLOR=\"#404040\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]gray</td>     <td BGCOLOR=\"#808080\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]green</td>    <td BGCOLOR=\"#00FF00\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]lightGray</td><td BGCOLOR=\"#C0C0C0\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]magenta</td>  <td BGCOLOR=\"#FF00FF\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]orange</td>   <td BGCOLOR=\"#FFC800\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]pink</td>     <td BGCOLOR=\"#FFAFAF\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]red</td>      <td BGCOLOR=\"#FF0000\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]white</td>    <td BGCOLOR=\"#FFFFFF\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]yellow</td>   <td BGCOLOR=\"#FFFF00\">&nbsp;</td></tr>\n</table>\n\n<h2>Note on exceptions</h2>\nRegular buggles throw a BuggleWallException exception if you ask them to\ntraverse a wall.  They throw a NoBaggleUnderBuggleException exception if you\nask them to pickup a baggle from an empty cell, or a\nAlreadyHaveBaggleException exception if they already carry a baggle.  Trying\nto drop a baggle on a cell already containing one throws an\nAlreadyHaveBaggleException exception. \nDropping a baggle when you have none throws a DontHaveBaggleException.\n<p>SimpleBuggles (ie, the one used in first exercises) display an error message\non problem so that you don't need to know what an exception is.</p>\n",
    "fr" : "\n<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->\n<h1>Le monde des Buggles</h1>\nCe monde a été inventé par Lyn Turbak, du Wellesley College. Il est peuplé\nde Buggles, petites bêtes qui comprennent des ordres simples, et offre de\nnombreuses possibilités d'interaction avec le monde : prendre ou poser des\nobjets, colorier le sol, se cogner à des murs, etc.\n\n<h2>Méthodes comprises par les buggles</h2>\n<table border=1>\n<tr><td colspan=2 align=center><b>Bouger</b><br/> (voir aussi la note sur les exceptions, plus bas)</td></tr>\n  <tr><td><b>Tourner à gauche<br/>Tourner à droite<br/>Se retourner<br/>Avancer<br/>Reculer</b></td>\n      <td>[!java|c]void [/!]gauche()<br/>\n          [!java|c]void [/!]droite()<br/>\n          [!java|c]void [/!]retourne()<br/>\n          [!java|c]void [/!][!python|java|scala]avance()[/!][!c]avancePas()[/!] or\n[!java|c]void [/!]avance([!java|c]int [/!]nbPas[!scala]:Int[/!])<br/>\n          [!java|c]void [/!][!python|java|scala]recule()[/!][!c]reculePas()[/!] or\n[!java]void [/!]recule([!java|c]int [/!]nbPas[!scala]:Int[/!])<br/></td></tr>\n  <tr><td><b>Obtenir l'abscisse<br/>Obtenir l'ordonnée<br/>Changer l'abscisse<br/>Changer l'ordonnée<br/>Changer la position</b></td>\n      <td>[!java|c]int [/!]getX()[!scala]:Int[/!]<br/>\n          [!java|c]int [/!]getY()[!scala]:Int[/!]<br/>\n          [!java|c]void [/!]setX([!java|c]int [/!]x[!scala]:Int[/!])<br/>\n          [!java|c]void [/!]setY([!java|c]int [/!]y[!scala]:Int[/!])<br/>\n          [!java|c]void [/!]setPos([!java|c]int [/!]x[!scala]:Int[/!], [!java|c]int\n[/!]y[!scala]:Int[/!])</td></tr>\n<tr><td colspan=2>L'origine (0, 0) est dans le coin en haut à gauche, comme c'est souvent le\ncas en informatique.</td></tr>\n\n<tr><td colspan=2 align=center><b>Informations sur la buggle</b></td></tr>\n  <tr><td><b>Obtenir la couleur de la buggle</b><br/>Changer la couleur de la buggle</b></td>\n      <td>[!java|c]Color [/!]getCouleurCorps()[!scala]:Color[/!]<br/>\n          [!java|c]void [/!]setCouleurCorps([!java|c]Color [/!]c[!scala]:Color[/!])</td></tr>\t\t\t\t\n  <tr><td><b>Chercher un mur devant<br/>Chercher un mur derrière</b></td>\n      <td>[!java]boolean [/!][!c]int [/!]estFaceMur()[!scala]:Boolean[/!]<br/>\n          [!java]boolean [/!][!c]int [/!]estDosMur()[!scala]:Boolean[/!]</td></tr>\t\t\t\t\n  <tr><td><b>Obtenir la direction<br/>Changer la direction</b><br/>Les directions valides sont :</td>\n      <td>[!java|c]Direction [/!]getDirection()[!scala]:Direction[/!]<br/>\n          [!java|c]void [/!]setDirection([!java|c]Direction\n[/!]dir[!scala]:Direction[/!])<br/>\n          [!scala|java|python]Direction.[/!]NORTH (nord),\n[!scala|java|python]Direction.[/!]EAST (est),\n[!scala|java|python]Direction.[/!]SOUTH (sud) et\n[!scala|java|python]Direction.[/!]WEST (ouest)</td></tr>\n  <tr><td>Renvoi si la buggle est actuellement <b>sélectionnée dans l'interface</b></td>\n      <td>[!java]boolean [/!][!c]int [/!]estChoisie()[!scala]:Boolean[/!]</td></tr>\n \n<tr><td colspan=2 align=center><b>À propos de la brosse</b></td></tr>\n  <tr><td><b>Baisser la brosse<br/>Lever la brosse<br/>Obtenir la position de la brosse</b></td>\n      <td>[!java|c]void [/!]leveBrosse()<br/>\n          [!java|c]void [/!]baisseBrosse()<br/>\n          [!java]boolean [/!][!c]int [/!]estBrosseBaissee()[!scala]:Boolean[/!]</td></tr>\n  <tr><td><b>Modifier la couleur de la brosse<br/>Obtenir la couleur de la brosse</b></td>\n      <td>[!java|c]void [/!]setCouleurBrosse([!java|c]Color [/!]c[!scala]:Color[/!])<br/>\n          [!java|c]Color [/!]getCouleurBrosse()[!scala]:Color[/!]</td></tr>\n\n<tr><td colspan=2 align=center><b>Interagir avec le monde</b></td></tr>\n  <tr><td><b>Obtenir la couleur du sol</b></td>\n      <td>[!java|c]Color [/!]getCouleurSol()[!scala]:Color[/!]</td></tr>\n\n  <tr><td><b>Vrai si biscuit par terre<br/>Vrai si on porte un biscuit<br/>Ramasse un biscuit<br/>Poser un biscuit</b><br/>\n      (voir la note sur les exceptions)</td>\n      <td>[!java]boolean [/!][!c]int [/!]estSurBiscuit()[!scala]:Boolean[/!]<br/>\n          [!java]boolean [/!][!c]int [/!]porteBiscuit()[!scala]:Boolean[/!]<br/>\n          [!java]void [/!]prendBiscuit()<br/>\n          [!java]void [/!]poseBiscuit()<br/>\n          &nbsp;</td></tr>\n\n  <tr><td><b>Chercher un message<br/>Ajouter un message<br/>Lire le message<br/>Effacer le message</b></td>\n      <td>[!java]boolean [/!][!c]int [/!]estSurMessage()[!scala]:Boolean[/!]<br/>\n          [!java]void [/!]ecritMessage([!java]String [/!][!c]char*\n[/!]msg[!scala]:String[/!])<br/>\n          [!java]String [/!][!c]char* [/!]litMessage()[!scala]:String[/!]<br/>\n          [!java]void [/!]effaceMessage()</td></tr>\n</table>\n\n<h2>Couleurs valides</h2>\n<table border=1>\n<tr><td>Nom</td><td>Couleur</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]black</td>    <td BGCOLOR=\"#000000\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]blue</td>     <td BGCOLOR=\"#0000FF\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]cyan</td>     <td BGCOLOR=\"#00FFFF\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]darkGray</td> <td BGCOLOR=\"#404040\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]gray</td>     <td BGCOLOR=\"#808080\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]green</td>    <td BGCOLOR=\"#00FF00\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]lightGray</td><td BGCOLOR=\"#C0C0C0\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]magenta</td>  <td BGCOLOR=\"#FF00FF\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]orange</td>   <td BGCOLOR=\"#FFC800\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]pink</td>     <td BGCOLOR=\"#FFAFAF\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]red</td>      <td BGCOLOR=\"#FF0000\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]white</td>    <td BGCOLOR=\"#FFFFFF\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]yellow</td>   <td BGCOLOR=\"#FFFF00\">&nbsp;</td></tr>\n</table>\n\n<h2>Note sur les exceptions</h2>\nLes buggles normales lèvent une exception BuggleWallException si on cherche\nà leur faire traverser un mur.\nElles lèvent une exception NoBaggleUnderBuggleException si vous cherchez à\nprendre un biscuit dans une case qui n'en contient pas, ou une exception\nAlreadyHaveBaggleException si vous portez déjà un biscuit.\nTenter de déposer un biscuit sur une case qui en contient déjà lève une\nexception AlreadyHaveBaggleException.\nTenter de poser un biscuit alors qu'on n'en a pas lève une exception\nDontHaveBaggleException.\n<p>Les \"SimpleBuggles\" (c.-à-d., celles utilisées dans les premiers exercices)\naffichent un message d'erreur sans que vous ayez à vous soucier de ce qu'est\nune exception.</p>\n"
  },
  "initialWorlds" : [ {
    "type" : "plm.universe.bugglequest.BuggleWorld",
    "@jsonId" : 1,
    "name" : "Closed World",
    "width" : 7,
    "height" : 7,
    "entities" : [ {
      "type" : "plm.universe.bugglequest.SimpleBuggle",
      "name" : "Buggle 1",
      "x" : 0,
      "y" : 3,
      "direction" : 0,
      "bodyColor" : [ 0, 0, 0, 255 ],
      "brushColor" : [ 192, 192, 192, 255 ],
      "world" : 1,
      "inited" : false,
      "brushDown" : false
    }, {
      "type" : "plm.universe.bugglequest.SimpleBuggle",
      "name" : "Buggle 2",
      "x" : 1,
      "y" : 3,
      "direction" : 0,
      "bodyColor" : [ 0, 0, 0, 255 ],
      "brushColor" : [ 192, 192, 192, 255 ],
      "world" : 1,
      "inited" : false,
      "brushDown" : false
    }, {
      "type" : "plm.universe.bugglequest.SimpleBuggle",
      "name" : "Buggle 3",
      "x" : 2,
      "y" : 3,
      "direction" : 0,
      "bodyColor" : [ 0, 0, 0, 255 ],
      "brushColor" : [ 192, 192, 192, 255 ],
      "world" : 1,
      "inited" : false,
      "brushDown" : false
    }, {
      "type" : "plm.universe.bugglequest.SimpleBuggle",
      "name" : "Buggle 4",
      "x" : 3,
      "y" : 3,
      "direction" : 0,
      "bodyColor" : [ 0, 0, 0, 255 ],
      "brushColor" : [ 192, 192, 192, 255 ],
      "world" : 1,
      "inited" : false,
      "brushDown" : false
    }, {
      "type" : "plm.universe.bugglequest.SimpleBuggle",
      "name" : "Buggle 5",
      "x" : 4,
      "y" : 3,
      "direction" : 0,
      "bodyColor" : [ 0, 0, 0, 255 ],
      "brushColor" : [ 192, 192, 192, 255 ],
      "world" : 1,
      "inited" : false,
      "brushDown" : false
    }, {
      "type" : "plm.universe.bugglequest.SimpleBuggle",
      "name" : "Buggle 6",
      "x" : 5,
      "y" : 3,
      "direction" : 0,
      "bodyColor" : [ 0, 0, 0, 255 ],
      "brushColor" : [ 192, 192, 192, 255 ],
      "world" : 1,
      "inited" : false,
      "brushDown" : false
    }, {
      "type" : "plm.universe.bugglequest.SimpleBuggle",
      "name" : "Buggle 7",
      "x" : 6,
      "y" : 3,
      "direction" : 0,
      "bodyColor" : [ 0, 0, 0, 255 ],
      "brushColor" : [ 192, 192, 192, 255 ],
      "world" : 1,
      "inited" : false,
      "brushDown" : false
    } ],
    "steps" : [ ],
    "about" : "<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->\n<h1>BuggleWorld</h1>\nThis world was invented by Lyn Turbak, at Wellesley College. It is full of\nBuggles, little animals understanding simple orders, and offers numerous\npossibilities of interaction with the world: taking or dropping objects,\npaint the ground, hit walls, etc.\n\n<h2>Methods understood by buggles</h2>\n<table border=1>\n<tr><td colspan=2 align=center><b>Moving</b><br/> (See also the note on exceptions, below)</td></tr>\n  <tr><td><b>Turn left<br/>Turn right<br/>Turn back<br/>Moving forward<br/>Moving back</b></td>\n      <td>void left()<br/>\n          void right()<br/>\n          void back()<br/>\n          void forward() or void forward(int steps)<br/>\n          void backward() or void backward(int steps)<br/></td></tr>\n  <tr><td><b>Get X coordinate<br/>Get Y coordinate<br/>Set X coordinate<br/>Set Y coordinate<br/>Set position</b></td>\n      <td>int getX()<br/>\n          int getY()<br/>\n          void setX(int x)<br/>\n          void setY(int y)<br/>\n          void setPos(int x, int y)</td></tr>\n<tr><td colspan=2>Note that the point (0,0) is on the top left corner, as it is often the case in Computer Science.</td></tr>\n\n<tr><td colspan=2 align=center><b>Information on the buggle</b></td></tr>\n  <tr><td><b>Get the color of the body<br/>Set the color of the body</b></td>\n      <td>Color getBodyColor()<br/>\n          void setBodyColor(Color c)</td></tr>\t\t\t\t\n  <tr><td><b>Look for a wall forward<br/>Look for a wall backward</b></td>\n      <td>boolean isFacingWall()<br/>\n          boolean isBackingWall()</td></tr>\t\t\t\t\n  <tr><td><b>Get heading<br/>Set heading</b><br/>valid directions are:</td>\n      <td>Direction getDirection()<br/>\n          void setDirection(Direction dir)<br/>\n          Direction.NORTH, Direction.EAST, Direction.SOUTH and Direction.WEST</td></tr>\n  <tr><td>Check whether the buggle is currently <b>selected in the interface</b></td>\n      <td>boolean isSelected()</td></tr>\n \n<tr><td colspan=2 align=center><b>About the brush</b></td></tr>\n  <tr><td><b>Brush down<br/>Brush up<br/>Get brush position</b></td>\n      <td>void brushUp()<br/>\n          void brushDown()<br/>\n          boolean isBrushDown()</td></tr>\n  <tr><td><b>Change the brush color<br/>Get the color of the brush</b></td>\n      <td>void setBrushColor(Color c)<br/>\n          Color getBrushColor()</td></tr>\n\n<tr><td colspan=2 align=center><b>Interacting with the world</b></td></tr>\n  <tr><td><b>Get the color of the ground</b></td>\n      <td>Color getGroundColor()</td></tr>\n\n  <tr><td><b>Look for a baggle on the ground<br/>Look for a baggle in bag<br/>Pickup a baggle<br/>Drop a baggle</b><br/>\n      (see the note on exceptions)</td>\n      <td>boolean isOverBaggle()<br/>\n          boolean isCarryingBaggle()<br/>\n          void pickupBaggle()<br/>\n          void dropBaggle()<br/>\n          &nbsp;</td></tr>\n\n  <tr><td><b>Look for a message<br/>Add a message<br/>Read the message<br/>Erase the message</b></td>\n      <td>boolean isOverMessage()<br/>\n          void writeMessage(String msg)<br/>\n          String readMessage()<br/>\n          void clearMessage()</td></tr>\n</table>\n\n<h2>Valid colors</h2>\n<table border=1>\n<tr><td>Name</td><td>Color</td></tr>\n<tr><td>Color.black</td>    <td BGCOLOR=\"#000000\">&nbsp;</td></tr>\n<tr><td>Color.blue</td>     <td BGCOLOR=\"#0000FF\">&nbsp;</td></tr>\n<tr><td>Color.cyan</td>     <td BGCOLOR=\"#00FFFF\">&nbsp;</td></tr>\n<tr><td>Color.darkGray</td> <td BGCOLOR=\"#404040\">&nbsp;</td></tr>\n<tr><td>Color.gray</td>     <td BGCOLOR=\"#808080\">&nbsp;</td></tr>\n<tr><td>Color.green</td>    <td BGCOLOR=\"#00FF00\">&nbsp;</td></tr>\n<tr><td>Color.lightGray</td><td BGCOLOR=\"#C0C0C0\">&nbsp;</td></tr>\n<tr><td>Color.magenta</td>  <td BGCOLOR=\"#FF00FF\">&nbsp;</td></tr>\n<tr><td>Color.orange</td>   <td BGCOLOR=\"#FFC800\">&nbsp;</td></tr>\n<tr><td>Color.pink</td>     <td BGCOLOR=\"#FFAFAF\">&nbsp;</td></tr>\n<tr><td>Color.red</td>      <td BGCOLOR=\"#FF0000\">&nbsp;</td></tr>\n<tr><td>Color.white</td>    <td BGCOLOR=\"#FFFFFF\">&nbsp;</td></tr>\n<tr><td>Color.yellow</td>   <td BGCOLOR=\"#FFFF00\">&nbsp;</td></tr>\n</table>\n\n<h2>Note on exceptions</h2>\nRegular buggles throw a BuggleWallException exception if you ask them to\ntraverse a wall.  They throw a NoBaggleUnderBuggleException exception if you\nask them to pickup a baggle from an empty cell, or a\nAlreadyHaveBaggleException exception if they already carry a baggle.  Trying\nto drop a baggle on a cell already containing one throws an\nAlreadyHaveBaggleException exception. \nDropping a baggle when you have none throws a DontHaveBaggleException.\n<p>SimpleBuggles (ie, the one used in first exercises) display an error message\non problem so that you don't need to know what an exception is.</p>\n",
    "parameters" : null,
    "cells" : [ [ {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 0,
      "y" : 0
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 0,
      "y" : 1
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 0,
      "y" : 2
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 0,
      "y" : 3,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "",
      "leftWall" : true,
      "topWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 0,
      "y" : 4,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "",
      "leftWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 0,
      "y" : 5,
      "topWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 0,
      "y" : 6
    } ], [ {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 1,
      "y" : 0
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 1,
      "y" : 1
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 1,
      "y" : 2,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "",
      "leftWall" : true,
      "topWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 1,
      "y" : 3
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 1,
      "y" : 4,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "",
      "leftWall" : true,
      "topWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 1,
      "y" : 5
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 1,
      "y" : 6
    } ], [ {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 2,
      "y" : 0
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 2,
      "y" : 1
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 2,
      "y" : 2,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "",
      "leftWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 2,
      "y" : 3,
      "topWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 2,
      "y" : 4,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "",
      "leftWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 2,
      "y" : 5,
      "topWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 2,
      "y" : 6
    } ], [ {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 3,
      "y" : 0
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 3,
      "y" : 1
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 3,
      "y" : 2,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "",
      "leftWall" : true,
      "topWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 3,
      "y" : 3
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 3,
      "y" : 4,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "",
      "leftWall" : true,
      "topWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 3,
      "y" : 5
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 3,
      "y" : 6
    } ], [ {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 4,
      "y" : 0
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 4,
      "y" : 1
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 4,
      "y" : 2,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "",
      "leftWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 4,
      "y" : 3,
      "topWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 4,
      "y" : 4,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "",
      "leftWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 4,
      "y" : 5,
      "topWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 4,
      "y" : 6
    } ], [ {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 5,
      "y" : 0
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 5,
      "y" : 1
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 5,
      "y" : 2,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "",
      "leftWall" : true,
      "topWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 5,
      "y" : 3
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 5,
      "y" : 4,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "",
      "leftWall" : true,
      "topWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 5,
      "y" : 5
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 5,
      "y" : 6
    } ], [ {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 6,
      "y" : 0
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 6,
      "y" : 1
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 6,
      "y" : 2,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "",
      "leftWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 6,
      "y" : 3,
      "topWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 6,
      "y" : 4,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "",
      "leftWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 6,
      "y" : 5,
      "topWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 6,
      "y" : 6
    } ] ],
    "visibleGrid" : true,
    "easter" : false
  } ],
  "answerWorlds" : [ {
    "type" : "plm.universe.bugglequest.BuggleWorld",
    "@jsonId" : 2,
    "name" : "Closed World",
    "width" : 7,
    "height" : 7,
    "entities" : [ {
      "type" : "plm.universe.bugglequest.SimpleBuggle",
      "name" : "Buggle 1",
      "world" : 2,
      "inited" : true,
      "bodyColor" : [ 0, 0, 0, 255 ],
      "brushColor" : [ 192, 192, 192, 255 ],
      "x" : 0,
      "y" : 4,
      "direction" : 0,
      "brushDown" : false
    }, {
      "type" : "plm.universe.bugglequest.SimpleBuggle",
      "name" : "Buggle 2",
      "world" : 2,
      "inited" : true,
      "bodyColor" : [ 0, 0, 0, 255 ],
      "brushColor" : [ 192, 192, 192, 255 ],
      "x" : 1,
      "y" : 2,
      "direction" : 0,
      "brushDown" : false
    }, {
      "type" : "plm.universe.bugglequest.SimpleBuggle",
      "name" : "Buggle 3",
      "world" : 2,
      "inited" : true,
      "bodyColor" : [ 0, 0, 0, 255 ],
      "brushColor" : [ 192, 192, 192, 255 ],
      "x" : 2,
      "y" : 4,
      "direction" : 0,
      "brushDown" : false
    }, {
      "type" : "plm.universe.bugglequest.SimpleBuggle",
      "name" : "Buggle 4",
      "world" : 2,
      "inited" : true,
      "bodyColor" : [ 0, 0, 0, 255 ],
      "brushColor" : [ 192, 192, 192, 255 ],
      "x" : 3,
      "y" : 2,
      "direction" : 0,
      "brushDown" : false
    }, {
      "type" : "plm.universe.bugglequest.SimpleBuggle",
      "name" : "Buggle 5",
      "world" : 2,
      "inited" : true,
      "bodyColor" : [ 0, 0, 0, 255 ],
      "brushColor" : [ 192, 192, 192, 255 ],
      "x" : 4,
      "y" : 4,
      "direction" : 0,
      "brushDown" : false
    }, {
      "type" : "plm.universe.bugglequest.SimpleBuggle",
      "name" : "Buggle 6",
      "world" : 2,
      "inited" : true,
      "bodyColor" : [ 0, 0, 0, 255 ],
      "brushColor" : [ 192, 192, 192, 255 ],
      "x" : 5,
      "y" : 2,
      "direction" : 0,
      "brushDown" : false
    }, {
      "type" : "plm.universe.bugglequest.SimpleBuggle",
      "name" : "Buggle 7",
      "world" : 2,
      "inited" : true,
      "bodyColor" : [ 0, 0, 0, 255 ],
      "brushColor" : [ 192, 192, 192, 255 ],
      "x" : 6,
      "y" : 4,
      "direction" : 0,
      "brushDown" : false
    } ],
    "steps" : [ [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 3,
      "buggleID" : "Buggle 1",
      "oldX" : 0,
      "oldY" : 3,
      "newX" : 0,
      "newY" : 4,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 4,
      "buggleID" : "Buggle 2",
      "oldX" : 1,
      "oldY" : 3,
      "newX" : 1,
      "newY" : 2,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 5,
      "buggleID" : "Buggle 4",
      "oldX" : 3,
      "oldY" : 3,
      "newX" : 3,
      "newY" : 2,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 6,
      "buggleID" : "Buggle 3",
      "oldX" : 2,
      "oldY" : 3,
      "newX" : 2,
      "newY" : 4,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 7,
      "buggleID" : "Buggle 5",
      "oldX" : 4,
      "oldY" : 3,
      "newX" : 4,
      "newY" : 4,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 8,
      "buggleID" : "Buggle 7",
      "oldX" : 6,
      "oldY" : 3,
      "newX" : 6,
      "newY" : 4,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 9,
      "buggleID" : "Buggle 6",
      "oldX" : 5,
      "oldY" : 3,
      "newX" : 5,
      "newY" : 2,
      "name" : "moveBuggleOperation"
    } ] ],
    "about" : "<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->\n<h1>BuggleWorld</h1>\nThis world was invented by Lyn Turbak, at Wellesley College. It is full of\nBuggles, little animals understanding simple orders, and offers numerous\npossibilities of interaction with the world: taking or dropping objects,\npaint the ground, hit walls, etc.\n\n<h2>Methods understood by buggles</h2>\n<table border=1>\n<tr><td colspan=2 align=center><b>Moving</b><br/> (See also the note on exceptions, below)</td></tr>\n  <tr><td><b>Turn left<br/>Turn right<br/>Turn back<br/>Moving forward<br/>Moving back</b></td>\n      <td>void left()<br/>\n          void right()<br/>\n          void back()<br/>\n          void forward() or void forward(int steps)<br/>\n          void backward() or void backward(int steps)<br/></td></tr>\n  <tr><td><b>Get X coordinate<br/>Get Y coordinate<br/>Set X coordinate<br/>Set Y coordinate<br/>Set position</b></td>\n      <td>int getX()<br/>\n          int getY()<br/>\n          void setX(int x)<br/>\n          void setY(int y)<br/>\n          void setPos(int x, int y)</td></tr>\n<tr><td colspan=2>Note that the point (0,0) is on the top left corner, as it is often the case in Computer Science.</td></tr>\n\n<tr><td colspan=2 align=center><b>Information on the buggle</b></td></tr>\n  <tr><td><b>Get the color of the body<br/>Set the color of the body</b></td>\n      <td>Color getBodyColor()<br/>\n          void setBodyColor(Color c)</td></tr>\t\t\t\t\n  <tr><td><b>Look for a wall forward<br/>Look for a wall backward</b></td>\n      <td>boolean isFacingWall()<br/>\n          boolean isBackingWall()</td></tr>\t\t\t\t\n  <tr><td><b>Get heading<br/>Set heading</b><br/>valid directions are:</td>\n      <td>Direction getDirection()<br/>\n          void setDirection(Direction dir)<br/>\n          Direction.NORTH, Direction.EAST, Direction.SOUTH and Direction.WEST</td></tr>\n  <tr><td>Check whether the buggle is currently <b>selected in the interface</b></td>\n      <td>boolean isSelected()</td></tr>\n \n<tr><td colspan=2 align=center><b>About the brush</b></td></tr>\n  <tr><td><b>Brush down<br/>Brush up<br/>Get brush position</b></td>\n      <td>void brushUp()<br/>\n          void brushDown()<br/>\n          boolean isBrushDown()</td></tr>\n  <tr><td><b>Change the brush color<br/>Get the color of the brush</b></td>\n      <td>void setBrushColor(Color c)<br/>\n          Color getBrushColor()</td></tr>\n\n<tr><td colspan=2 align=center><b>Interacting with the world</b></td></tr>\n  <tr><td><b>Get the color of the ground</b></td>\n      <td>Color getGroundColor()</td></tr>\n\n  <tr><td><b>Look for a baggle on the ground<br/>Look for a baggle in bag<br/>Pickup a baggle<br/>Drop a baggle</b><br/>\n      (see the note on exceptions)</td>\n      <td>boolean isOverBaggle()<br/>\n          boolean isCarryingBaggle()<br/>\n          void pickupBaggle()<br/>\n          void dropBaggle()<br/>\n          &nbsp;</td></tr>\n\n  <tr><td><b>Look for a message<br/>Add a message<br/>Read the message<br/>Erase the message</b></td>\n      <td>boolean isOverMessage()<br/>\n          void writeMessage(String msg)<br/>\n          String readMessage()<br/>\n          void clearMessage()</td></tr>\n</table>\n\n<h2>Valid colors</h2>\n<table border=1>\n<tr><td>Name</td><td>Color</td></tr>\n<tr><td>Color.black</td>    <td BGCOLOR=\"#000000\">&nbsp;</td></tr>\n<tr><td>Color.blue</td>     <td BGCOLOR=\"#0000FF\">&nbsp;</td></tr>\n<tr><td>Color.cyan</td>     <td BGCOLOR=\"#00FFFF\">&nbsp;</td></tr>\n<tr><td>Color.darkGray</td> <td BGCOLOR=\"#404040\">&nbsp;</td></tr>\n<tr><td>Color.gray</td>     <td BGCOLOR=\"#808080\">&nbsp;</td></tr>\n<tr><td>Color.green</td>    <td BGCOLOR=\"#00FF00\">&nbsp;</td></tr>\n<tr><td>Color.lightGray</td><td BGCOLOR=\"#C0C0C0\">&nbsp;</td></tr>\n<tr><td>Color.magenta</td>  <td BGCOLOR=\"#FF00FF\">&nbsp;</td></tr>\n<tr><td>Color.orange</td>   <td BGCOLOR=\"#FFC800\">&nbsp;</td></tr>\n<tr><td>Color.pink</td>     <td BGCOLOR=\"#FFAFAF\">&nbsp;</td></tr>\n<tr><td>Color.red</td>      <td BGCOLOR=\"#FF0000\">&nbsp;</td></tr>\n<tr><td>Color.white</td>    <td BGCOLOR=\"#FFFFFF\">&nbsp;</td></tr>\n<tr><td>Color.yellow</td>   <td BGCOLOR=\"#FFFF00\">&nbsp;</td></tr>\n</table>\n\n<h2>Note on exceptions</h2>\nRegular buggles throw a BuggleWallException exception if you ask them to\ntraverse a wall.  They throw a NoBaggleUnderBuggleException exception if you\nask them to pickup a baggle from an empty cell, or a\nAlreadyHaveBaggleException exception if they already carry a baggle.  Trying\nto drop a baggle on a cell already containing one throws an\nAlreadyHaveBaggleException exception. \nDropping a baggle when you have none throws a DontHaveBaggleException.\n<p>SimpleBuggles (ie, the one used in first exercises) display an error message\non problem so that you don't need to know what an exception is.</p>\n",
    "parameters" : null,
    "cells" : [ [ {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 0,
      "y" : 0
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 0,
      "y" : 1
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 0,
      "y" : 2
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 0,
      "y" : 3,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "",
      "leftWall" : true,
      "topWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 0,
      "y" : 4,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "",
      "leftWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 0,
      "y" : 5,
      "topWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 0,
      "y" : 6
    } ], [ {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 1,
      "y" : 0
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 1,
      "y" : 1
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 1,
      "y" : 2,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "",
      "leftWall" : true,
      "topWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 1,
      "y" : 3
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 1,
      "y" : 4,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "",
      "leftWall" : true,
      "topWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 1,
      "y" : 5
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 1,
      "y" : 6
    } ], [ {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 2,
      "y" : 0
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 2,
      "y" : 1
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 2,
      "y" : 2,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "",
      "leftWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 2,
      "y" : 3,
      "topWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 2,
      "y" : 4,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "",
      "leftWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 2,
      "y" : 5,
      "topWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 2,
      "y" : 6
    } ], [ {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 3,
      "y" : 0
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 3,
      "y" : 1
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 3,
      "y" : 2,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "",
      "leftWall" : true,
      "topWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 3,
      "y" : 3
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 3,
      "y" : 4,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "",
      "leftWall" : true,
      "topWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 3,
      "y" : 5
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 3,
      "y" : 6
    } ], [ {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 4,
      "y" : 0
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 4,
      "y" : 1
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 4,
      "y" : 2,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "",
      "leftWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 4,
      "y" : 3,
      "topWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 4,
      "y" : 4,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "",
      "leftWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 4,
      "y" : 5,
      "topWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 4,
      "y" : 6
    } ], [ {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 5,
      "y" : 0
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 5,
      "y" : 1
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 5,
      "y" : 2,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "",
      "leftWall" : true,
      "topWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 5,
      "y" : 3
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 5,
      "y" : 4,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "",
      "leftWall" : true,
      "topWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 5,
      "y" : 5
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 5,
      "y" : 6
    } ], [ {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 6,
      "y" : 0
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 6,
      "y" : 1
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 6,
      "y" : 2,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "",
      "leftWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 6,
      "y" : 3,
      "topWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 6,
      "y" : 4,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "",
      "leftWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 6,
      "y" : 5,
      "topWall" : true
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 6,
      "y" : 6
    } ] ],
    "visibleGrid" : true,
    "easter" : false
  } ],
  "instructions" : {
    "pt" : "\n<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->\n<h2>Instruções condicionais</h2>\n\nProgramas feitos simplesmente de um conjunto de instruções similares\nao do exercício anterior são bastante chatos. Eles sempre fazem a\nmesma coisa, e não reajem a condições externas. Um <b>condicional</b>\nfaz o programa se adaptar fazendo coisas do tipo <i>se está chovendo,\npegue um guarda-chuva</i>. \n\n<p>A sintaxe de [!thelang] é a seguinte:</p>\n\n<pre><code class=\"code-container\">[!java|scala|c]if (<b>condition</b>) {\n&nbsp;&nbsp;&nbsp;&nbsp;<b>whatToDoIfTrue();</b>\n&nbsp;&nbsp;&nbsp;&nbsp;<b>whatToDoNextIfTrue();</b>\n}[/!][!python]if <b>condition</b>:\n&nbsp;&nbsp;&nbsp;&nbsp;<b>whatToDoIfTrue()</b>\n&nbsp;&nbsp;&nbsp;&nbsp;<b>whatToDoNextIfTrue()</b>[/!]\n<b>whatToDoAnyway()[!java|c];[/!]</b></code></pre>\n\n<p>Se a condição for verdade, o código do próximo bloco será executado e então\no resto do código continua. Se a condição for falsa, o próximo bloco é\nignorado e a execução continua depois disto. O bloco condicional pode conter\nvárias instruções, pode até mesmo conter outros testes, com seus próprios\nsub-testes.</p>\n\n<p>Neste exemplo, as instruções <code>oQueFazerSeForVerdade()</code> e\n<code>oQueFazerDepoisSeForVerdade()</code> serão executadas se e somente se\na condição for verdadeira, mas a instrução\n<code>oQueFazerDeUmJeitoOuDeOutro()</code> vai ser executada se a condição\nfor verdadeira ou não. \n</p>\n\n<p>Em [!thelang], os blocos de código são [!java|scala|c]envolvidos entre\nchaves: um { abre o bloco, e um } fecha. Espaços em branco não são\nimportantes[/!][!java|c].[/!][!scala], uma vez que suas instruções ainda\nestejam separadas com um ponto-e-vírgula ou um fim-de-linha.[/!]\n[!java|scala|c]Ainda assim é muito importante indentar corretamente seu\ncódigo para mantê-lo legível.[/!] [!python]marcados pela indentação: todas\nas linhas que estiverem um pouco deslocadas para a direita com espaços\npertencem ao bloco. Frequentemente se usam 4 espaços para indentação, mas\nfunciona se você usar mais ou menos espaços. Resumindo, quaisquer linhas do\nbloco devem usar a mesma quantidade de espaços. O fim do bloco de código\nPython não é marcado por nenhum caractere específico. Indentar linhas começa\num bloco e parar de indentar termina o bloco. Não esqueça do dois-pontos (:)\nno final da linha do <code>if</code>, python precisa dele para saber que um\nnovo bloco vai começar. O fato de que python se baseia em indentação para\ndelimitar blocos é uma ótima propriedade para iniciantes: vai forçar você a\naderir a padrões de apresentação de código estritos.[/!] É muito fácil se\nperder no seu próprio código se ele não for corretamente indentado, então\nvocê precisa deixar ele bem arrumado para que trabalhar nele continue sendo\nagradável e produtivo.</p>\n\n[!python]\n<p>Todas as indentações de um dado bloco devem ser consistentes, e não é\npossível cortar um bloco. os dois códigos a seguir estão incorretos e devem\nresultar em erro.</p>\n<pre><code class=\"code-container\">if <b>condition</b>:\n&nbsp;&nbsp;&nbsp;&nbsp;<b>whatToDo()</b>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>whatToDoNext()</b> <span class=\"comment\"># one space too much </span>\n<b>whatToDoAnyway()</b>\n</code></pre>\n<pre><code class=\"code-container\">if <b>condition</b>:\n&nbsp;&nbsp;&nbsp;&nbsp;<b>whatToDo()</b>\n<b>whatToDoAnyway()</b>\n&nbsp;&nbsp;&nbsp;&nbsp;<b>whatToDoNext()</b> <span class=\"comment\"># this block is not hanging to a condition line</span>\n</code></pre>\n[/!]\n<p>A condição deve ser uma expressão\n<code>[!c]int[/!][!java]boolean[/!][!scala|python]Boolean[/!]</code>. O\nbloco interno do código será executado se a expressão for calculada como\n<code>[!c]1[/!][!java|scala]true[/!][!python]True[/!]</code> e será ignorado\nse for\n<code>[!c]0[/!][!java|scala]false[/!][!python]False[/!]</code>.\n[!python|scala|java]<code>[!java|scala]true[/!][!python]True[/!]</code> e\n<code>[!java|scala]false[/!][!python]False[/!]</code> são valores constantes\ndefinidos por [!thelang] diretamente, assim como 0 ou 1 na matemática.[/!]</p>\n\n<p>A condição pode ser uma variável\n<code>[!c]int[/!][!java]boolean[/!][!scala|python]Boolean[/!]</code> (vamos\nvoltar a falar de variáveis num próximo exercício, não se preocupe) ou um\nteste aritmético, como <code>x == 5</code>, que verifica se o valor atual de\n<code>x</code> é 5, ou algo como <b>!=</b> (verificando inequação, ou seja,\nretornando [!c]1[/!][!java|scala]true[/!][!python]True[/!] apenas se o lado\nesquerdo é diferente do lado direito), <b>&lt;</b> (menor que), <b>&gt;</b>\n(maior que), <b>&lt;=</b> (menor ou igual a), <b>&gt;=</b> (maior ou igual\na).</p>\n\n<p>Cuidado com um erro clássico, que é verificar a igualdade da variável usando\n= no lugar de ==. Ainda bem que o\n[!java|scala|c]compilador[/!][!python]interpretador[/!] detecta este\nproblema na maior parte das vezes, mas às vezes passa (como quando você está\natribuindo valor a uma variável\n[!c]int[/!][!java|python|scala]booleana[/!]). Então é bom ter cuidado...</p>\n\n<p>A condição pode também ser uma chamada para alguns métodos\nparticulares que retornam booleano. Por exemplo, o método\n<code>estáDeFrenteParaParede()</code> do buggle retorna\n[!c]1[/!][!java|python|scala]true[/!] se o buggle está olhando para\numa parede, e false caso contrário.</p>\n\n<p>Finalmente, uma condição pode ser composta de várias sub-condições\nconectadas por operadores booleanos:</p>\n<ul>\n  <li><code>cond1 [!java|scala|c]&&[/!][!python]and[/!] cond2</code> é verdadeiro\n(true) quando <tt>cond1</tt> <b>e</b> <tt>cond2</tt> são ambos verdadeiros\n(se <tt>cond1</tt> é falso (false), <tt>cond2</tt> não é nem sequer\ncalculado pois sabe-se previamente que a conjunção das duas proposições não\npode ser verdadeira).</li> \n  <li><code>cond1 [!java|scala|c]||[/!][!python]or[/!] cond2</code> é verdadeiro\nse <tt>cond1</tt> <b>ou</b> <tt>cond2</tt> é verdadeiro (se <tt>cond1</tt> é\nverdadeiro, <tt>cond2</tt> não é nem sequer calculada pois já se sabe que a\ndisjunção de ambas as proposições não pode ser verdadeira).</li>\n  <li><code>[!java|scala|c]![/!][!python]not [/!]cond</code> é verdadeira se\n<tt>cond</tt> é falsa.</li>\n  <li>Quando a expressão se torna complicada, é melhor adicionar parêntesis para\nforçar a ordem de cálculo. Não hesite em adicionar mais parêntesis para\nremover ambiguidades que apareçam na expressão.</li>\n</ul> \n\n<p>Por fim, é possível especificar o que fazer quando a condição é falsa usando\na seguinte sintaxe. Neste caso, a instrução <code>oQueFazerSeForFalso</code>\nserá executada apenas se a condição for falsa.</p>\n <pre><code class=\"code-container\">[!java|scala|c]if (<b>condition</b>) {\n&nbsp;&nbsp;&nbsp;&nbsp;<b>whatToDoIfTheConditionIsTrue();</b>\n} else {\n&nbsp;&nbsp;&nbsp;&nbsp;<b>whatToDoIfItsFalse();</b>\n}[/!][!python]if (<b>condition</b>):\n&nbsp;&nbsp;&nbsp;&nbsp;<b>whatToDoIfTheConditionIsTrue()</b>\nelse:\n&nbsp;&nbsp;&nbsp;&nbsp;<b>whatToDoIfItsFalse()</b>[/!]</code></pre>\n[!python]\n<p>Não esqueça do dois-pontos (:) depois do else, ele indica que um novo bloco\nestá começando.</p>\n[/!]\n<h3>Objetivo do exercício</h3><a name=\"Objectives\"/> Se o buggle está de cara numa parede, você deve se\nmover um passo para trás. Se não, você deve se mover um passo para\nfrente. para detectar se você está de cara para uma parede, simplesmente use\na função pré-fabricada <code>estáDeFrenteParaParede()</code>, que todo\nbuggle entende. \n\n<p>Este exercício é um pouco diferente: seu código tem que funcionar para\nvários buggles, cada um começando numa posição diferente. O mesmo código\nserá executado para cada um deles.</p>\n\n<p>Quando o seu programa funciona, vá para o próximo exercício.</p>\n",
    "en" : "<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->\n<h2>Conditional instructions</h2>\n\nPrograms made of simple suite of instructions similar to previous exercise\nare quite boring. They always do the same thing, and cannot react to\nexternal conditions. A <b>conditional</b> let the program adapt by doing\nsomething like <i>if it's raining, take an umbrella</i>. \n\n<p>The [!thelang] syntax is the following:</p>\n\n<pre><code class=\"code-container\">[!java|scala|c]if (<b>condition</b>) {\n&nbsp;&nbsp;&nbsp;&nbsp;<b>whatToDoIfTrue();</b>\n&nbsp;&nbsp;&nbsp;&nbsp;<b>whatToDoNextIfTrue();</b>\n}[/!][!python]if <b>condition</b>:\n&nbsp;&nbsp;&nbsp;&nbsp;<b>whatToDoIfTrue()</b>\n&nbsp;&nbsp;&nbsp;&nbsp;<b>whatToDoNextIfTrue()</b>[/!]\n<b>whatToDoAnyway()[!java|c];[/!]</b></code></pre>\n\n<p>If the condition is true, the code of the next block will be executed and then it will continue with the rest of the code.\nIf the condition is false, the next block is ignored and the execution continues after it.\nThe conditional block can contain several instructions, it can even contain other tests, along with their sub-blocks.</p>\n\n<p>In this example, the instructions <code>whatToDoIfTrue()</code> and <code>whatToDoNextIfTrue()</code> \nwill be executed if and only if the condition is true, \nwhile the instruction <code>whatToDoAnyway()</code> will be executed whether or not the condition is true. \n</p>\n\n<p>In [!thelang], the blocks of code are\n[!java|scala|c]enclosed between curly brackets: a { sign opens the block, while a } sign closes it. \nWhite spaces are not important[/!][!java|c].[/!][!scala], provided that your instructions are still separated with a semi-column or an end of line.[/!]\n[!java|scala|c]It is still very important to correctly indent your code to keep it readable.[/!]\n[!python]marked by the indentation: every lines that are a bit shifted to the right with \nwhite spaces belong to the block. Quite often, people use 4 spaces for indentation, \nbut it works if you use more or less spaces. Simply, any lines of the block must use the same amount of spaces.\nThe end of Python code blocks are not marked by any specific char.\nIndenting lines starts a block and unindenting ends it. Do not forget the colon (:) at the end of \nthe <code>if</code> line, python needs it to know that a new block begins. The fact that python relies on \nindentation to delimit blocks is a very good property for beginners: it will force you to adhere to strict \ncode presentation standards.[/!]\nIt is very easy to get lost in your own code if it's not properly indented, so you want to clean it up so that \nworking on your code remains pleasant and productive.</p>\n\n[!python]\n<p>All indentations of a given block must be consistent, and it is not \npossible to cut a block. The two following codes are incorrect and will raise\nerrors.</p>\n<pre><code class=\"code-container\">if <b>condition</b>:\n&nbsp;&nbsp;&nbsp;&nbsp;<b>whatToDo()</b>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>whatToDoNext()</b> <span class=\"comment\"># one space too much </span>\n<b>whatToDoAnyway()</b>\n</code></pre>\n<pre><code class=\"code-container\">if <b>condition</b>:\n&nbsp;&nbsp;&nbsp;&nbsp;<b>whatToDo()</b>\n<b>whatToDoAnyway()</b>\n&nbsp;&nbsp;&nbsp;&nbsp;<b>whatToDoNext()</b> <span class=\"comment\"># this block is not hanging to a condition line</span>\n</code></pre>\n[/!]\n<p>The condition must be a <code>[!c]int[/!][!java]boolean[/!][!scala|python]Boolean[/!]</code> expression. \nThe inner block of code will get executed if the expression is evaluated to  <code>[!c]1[/!][!java|scala]true[/!][!python]True[/!]</code> \nand it will be ignored if it is <code>[!c]0[/!][!java|scala]false[/!][!python]False[/!]</code>.\n[!python|scala|java]<code>[!java|scala]true[/!][!python]True[/!]</code> and <code>[!java|scala]false[/!][!python]False[/!]</code> are constant values \ndefined by [!thelang] directly, just as 0 or 1 in mathematics.[/!]</p>\n\n<p>The condition can be a <code>[!c]int[/!][!java]boolean[/!][!scala|python]Boolean[/!]</code> variable \n(we will come back on variables in a later exercise, don't worry) or \nan arithmetic test, such as <code>x == 5</code>, which checks whether the current value of \n<code>x</code> is 5, or such as <b>!=</b> (checking inequality, that is, returning [!c]1[/!][!java|scala]true[/!][!python]True[/!] \nonly if the left-hand side is different from the right-hand side), <b>&lt;</b> (smaller than), \n<b>&gt;</b> (larger than), <b>&lt;=</b> (smaller or equal to), <b>&gt;=</b> (larger or equal to).</p>\n\n<p>Beware of the classical trap, which consists in testing the equality of a\nvariable using = instead of ==. Hopefully, the [!java|scala|c]compiler[/!][!python]interpreter[/!] \ndetects this problem most of the time, but it could get trapped is some cases (such as when you are \naffecting a [!c]int[/!][!java|python|scala]boolean[/!] variable). So you'd better to be careful...</p>\n\n<p>The condition can also be a call to some particular methods returning a\nboolean. For example, the <code>isFacingWall()</code> method of the buggle\nreturns [!c]1[/!][!java|python|scala]true[/!] if the buggle is facing a wall, and [!c]0[/!][!java|python|scala]false[/!] in the other case.</p>\n\n<p>Finally, a condition can be composed of several sub-conditions connected by\nboolean operations:</p>\n<ul>\n  <li><code>cond1 [!java|scala|c]&&[/!][!python]and[/!] cond2</code> is true when <tt>cond1</tt> <b>and</b>\n      <tt>cond2</tt> are both true (if <tt>cond1</tt> is false,\n      <tt>cond2</tt> is not even evaluated as we already know that the conjunction of both propositions cannot be true).</li> \n  <li><code>cond1 [!java|scala|c]||[/!][!python]or[/!] cond2</code> is true if <tt>cond1</tt> <b>or</b> \n      <tt>cond2</tt> is true (if <tt>cond1</tt> is true, <tt>cond2</tt> is not even evaluated\n      as we already know that the disjunction of both propositions cannot be false).</li>\n  <li><code>[!java|scala|c]![/!][!python]not [/!]cond</code> is true if <tt>cond</tt> is false.</li>\n  <li>When the expression becomes complicated, it is better to add parenthesis to force the order of evaluation.\n      Do not hesitate to add more parenthesis to remove any ambiguities that may appear in an expression.</li>\n</ul> \n\n<p>Last, it is possible to specify what to do when the condition is false\nusing the following syntax. In this case, the instruction <code>whatToDoIfItsFalse</code>\nwill be executed only if the condition is false.</p>\n <pre><code class=\"code-container\">[!java|scala|c]if (<b>condition</b>) {\n&nbsp;&nbsp;&nbsp;&nbsp;<b>whatToDoIfTheConditionIsTrue();</b>\n} else {\n&nbsp;&nbsp;&nbsp;&nbsp;<b>whatToDoIfItsFalse();</b>\n}[/!][!python]if (<b>condition</b>):\n&nbsp;&nbsp;&nbsp;&nbsp;<b>whatToDoIfTheConditionIsTrue()</b>\nelse:\n&nbsp;&nbsp;&nbsp;&nbsp;<b>whatToDoIfItsFalse()</b>[/!]</code></pre>\n[!python]\n<p>Don't forget the colon (:) after the else, it is indicating \nthat a new block is beginning.</p>\n[/!]\n<h3>Exercise goal</h3><a name=\"Objectives\"/>\n\nIf the buggle is facing a wall, you must move one step back. If not,\nyou must move one step forward. To detect whether you are facing a wall, \nsimply use the <code>isFacingWall()</code> built-in, that every buggle \nunderstands. \n\n<p>This exercise is a bit different: your code has to work for several buggles,\neach of them being in a specific initial condition. The same code will be\nexecuted for each of them.</p>\n\n<p>When your program works, move forward to the next exercise.</p>\n",
    "fr" : "\n<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->\n<h2>Instructions conditionnelles</h2>\n\nLes programmes faits d'une simple suite d'instructions comme celui de\nl'exercice précédent sont bien ennuyeux. Ils font toujours la même chose, et\nne peuvent pas réagir aux conditions extérieurs. Une <b>instruction\nconditionnelle</b> permet au programme de s'adapter en disant quelque chose\ncomme <i>S'il pleut, prend un parapluie</i>. \n\n<p>La syntaxe en [!thelang] est la suivante :</p>\n\n<pre><code class=\"code-container\">[!java|scala|c]if (<b>condition</b>) {\n&nbsp;&nbsp;&nbsp;&nbsp;<b>aFaireSiVraie();</b>\n&nbsp;&nbsp;&nbsp;&nbsp;<b>aFaireEnsuiteSiVraie();</b>\n}[/!][!python]if <b>condition</b>:\n&nbsp;&nbsp;&nbsp;&nbsp;<b>aFaireSiVraie()</b>\n&nbsp;&nbsp;&nbsp;&nbsp;<b>aFaireEnsuiteSiVraie()</b>[/!]\n<b>aFaireDansTousLesCas()[!java|c];[/!]</b></code></pre>\n\n<p>Le mot <code>if</code> signifie «si» en anglais. Si la condition est vraie,\nalors le code du bloc suivant sera exécuté, puis l'exécution se poursuivra\navec la suite du code, après le bloc. Sinon, si la condition est fausse, le\nbloc suivant sera ignoré et l'exécution passera directement au code placé\naprès lui. Le bloc conditionnel peut contenir plusieurs instructions. Il\npeut même contenir d'autre tests, avec leurs sous-blocs associés.</p>\n\n<p>Dans cet exemple, les instructions <code>aFaireSiVraie()</code> et\n<code>aFaireEnsuiteSiVraie()</code> seront exécutée si (et seulement si) la\ncondition est vraie tandis que l'instruction\n<code>aFaireDansTousLesCas()</code> sera exécutée que la condition soit\nvraie ou fausse. \n</p>\n\n<p>En [!thelang], les blocs sont\n[!java|scala|c]délimités par des accolades : le symbole { commence un bloc\ntandis\nque le symbole } le ferme.  Les caractères blancs ne sont pas pris en\ncompte[/!][!java|c].[/!][!scala], tant que les instructions restent séparées\nsoit par des points-virgules, soit par des retour à la ligne.[/!]\n[!java|scala|c]Il reste très important d'indenter correctement votre code\npour qu'il reste lisible.[/!]\n[!python]marqués par l'indentation : toutes les lignes indentés (=décalées\nvers la droite par des espaces) font partie du bloc. Il est assez courant\nd'utiliser quatre espaces pour indenter le code, mais cela fonctionne quel\nque soit le nombre de caractères blancs utilisés pour cela. Simplement,\ntoutes les lignes d'un bloc donné doivent utiliser le même nombre de\nblancs. La fin des blocs de code n'est pas marquée par un symbole\nparticulier: il s'arrête dès que les lignes ne sont plus\nindentées. N'oubliez pas les deux points (:) à la fin de la ligne\n<code>if</code>, python en a besoin pour savoir qu'un nouveau bloc commence.\nLe fait que python utilise l'indentation pour maquer les blocs est un\navantage pour les débutants: cela vous forcera à respecter des critères\nstricts de mise en forme de votre code.[/!]\nIl est très facile de se perdre dans un code qui n'est pas correctement\nindenté. Il est donc important que vous fassiez en sorte que votre code\nreste clair et lisible pour que le relire et le modifier reste plaisant et\nproductif.</p>\n\n[!python]\n<p>Toutes les instructions d'un bloc doivent avoir la même indentation, et il\nn'est pas possible de couper un bloc. Les deux exemples suivants de code\nsont incorrects et vont générer des erreurs.</p>\n<pre><code class=\"code-container\">if <b>condition</b>:\n&nbsp;&nbsp;&nbsp;&nbsp;<b>quoiFaire()</b>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>quoiFaireEnsuite()</b> <span class=\"comment\"># une espace de trop</span>\n<b>quoiFaireDansTousLesCas()</b>\n</code></pre>\n<pre><code class=\"code-container\">if <b>condition</b>:\n&nbsp;&nbsp;&nbsp;&nbsp;<b>quoiFaire()</b>\n<b>quoiFaireDansTousLesCas()</b>\n&nbsp;&nbsp;&nbsp;&nbsp;<b>quoiFaireEnsuite()</b> <span class=\"comment\"># Ce bloc n'est rattaché à aucune ligne de condition</span>\n</code></pre>\n[/!]\n<p>La condition doit être une expression de type\n<code>[!c]int[/!][!java]boolean[/!][!scala|python]Boolean[/!]</code>\n(expression booléenne).  Le sous-bloc sera exécuté seulement si cette\nexpression vaut <code>[!c]1[/!][!java|scala]true[/!][!python]True[/!]</code>\n(vrai), et il sera ignoré si sa valeur est\n<code>[!c]0[/!][!java|scala]false[/!][!python]False[/!]</code> (faux).\n<code>[!java|scala]true[/!][!python]True[/!]</code> et\n<code>[!java|scala]false[/!][!python]False[/!]</code> sont des constantes\ndéfinies directement par [!thelang], tout comme 0 ou 1 en mathématiques.</p>\n\n<p>La condition peut aussi être une variable booléenne (nous reviendrons sur\nles variables dans un autre exercice, pas de panique) ou un test\narithmétique,comme <code>x == 5</code>, qui teste si la valeur actuelle de\n<tt>x</tt> est 5, ou bien comme <b>!=</b> (teste l'inégalité, càd si le\nmembre gauche a une valeur différente du membre droit), <b>&lt;</b>\n(inférieur à), <b>&gt;</b> (supérieur à), <b>&lt;=</b> (inférieur ou égal\nà), <b>&gt;=</b> (supérieur ou égal à).</p>\n\n<p>Attention au piège classique, qui consiste à tester l'égalité d'une variable\navec = au lieu de ==. Heureusement, [!java|scala|c]le\ncompilateur[/!][!python]l'interpréteur[/!] détecte le plus souvent ce\nproblème et vous le signale, mais pas tout le temps. Si la variable est de\ntype booléen, il peut se faire prendre au piège, et il convient donc d'être\nattentif...</p>\n\n<p>La condition peut également être un appel à certaines méthodes\nparticulières, dont le résultat est un booléen. Par exemple, la méthode\n<tt>estFaceMur()</tt> de la buggle renvoie\n[!c]1[/!][!java|python|scala]vrai[/!] si la buggle est face à un mur, et\n[!c]0[/!][!java|python|scala]faux[/!] sinon.</p>\n\n<p>Enfin, il est possible de construire une condition composée de plusieurs\nsous-conditions reliées par des opérations booléennes:</p>\n<ul>\n  <li><code>cond1 [!java|scala|c]&&[/!][!python]and[/!] cond2</code> est vraie si\n<tt>cond1</tt> <b>et</b> <tt>cond2</tt> est vraie (d'ailleurs, si\n<tt>cond1</tt> est fausse, <tt>cond2</tt> n'est même pas évaluée puisqu'on\nsait déjà que la conjonction des deux propositions ne peut pas être vraie).</li> \n  <li><code>cond1 [!java|scala|c]||[/!][!python]or[/!] cond2</code> est vraie si\n<tt>cond1</tt> <b>ou</b> <tt>cond2</tt> est vraie (d'ailleurs, si\n<tt>cond1</tt> est vraie, <tt>cond2</tt> n'est même pas évaluée puisqu'on\nsait déjà que la disjonction des deux propositions ne peut pas être fausse).</li>\n  <li><code>[!java|scala|c]![/!][!python]not [/!]cond</code> est vraie si\n<tt>cond</tt> ne l'est pas.</li>\n  <li>Quand les expressions deviennent compliquées, il est préférable d'ajouter\nquelques parenthèses pour lever toute ambiguïté sur l'ordre\nd'évaluation. N'hésitez pas à mettre suffisamment de parenthèses pour la\nrendre plus lisible.</li>\n</ul> \n\n<p>Pour finir, il est possible de spécifier ce qu'il faut faire quand la\ncondition est fausse, en utilisant la syntaxe suivante («else» signifie\n«sinon» en anglais). Dans ce cas, l'instruction\n<code>aFaireSiLaConditionEstFausse()</code> ne sera exécutée que si la\ncondition est fausse.</p>\n <pre><code class=\"code-container\">[!java|scala|c]if (<b>condition</b>) {\n&nbsp;&nbsp;&nbsp;&nbsp;<b>aFaireSiLaConditionEstVraie();</b>\n} else {\n&nbsp;&nbsp;&nbsp;&nbsp;<b>aFaireSiElleEstFausse();</b>\n}[/!][!python]if (<b>condition</b>):\n&nbsp;&nbsp;&nbsp;&nbsp;<b>aFaireSiLaConditionEstVraie()</b>\nelse:\n&nbsp;&nbsp;&nbsp;&nbsp;<b>aFaireSiElleEstFausse()</b>[/!]</code></pre>\n[!python]\n<p>N'oubliez pas les deux points (:) après le else, ils indiquent qu'un nouveau\nbloc débute.</p>\n[/!]\n<h3>Objectif de cet exercice</h3><a name=\"Objectifs\"/> Si la buggle est face à un mur, il faut reculer d'un\npas; Sinon, il faut avancer d'un pas.\nPour savoir si on est face à un mur, il suffit d'utiliser la méthode\nprédéfinie des buggles nommée <code>estFaceMur()</code>. \n\n<p>Cet exercice est un peu particulier : il faut que votre programme fonctionne\npour plusieurs buggles, chacune étant dans une situation initiale\ndifférente. Le même code sera utilisé pour chacune d'entre elles.</p>\n\n<p>Quand votre programme fonctionne enfin, passez à l'exercice suivant.</p>\n"
  }
}