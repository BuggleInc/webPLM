{
  "id" : "bdr.BDR",
  "name" : "BDR",
  "tabName" : "BDRBuggle",
  "defaultSourceFiles" : {
    "Java" : {
      "name" : "BDR",
      "body" : "",
      "template" : "$package   import java.io.BufferedWriter; import java.io.IOException;  public class BDR extends plm.universe.bugglequest.SimpleBuggle {\t \t@Override \tpublic void command(String command, BufferedWriter out) { \t\tint num = Integer.parseInt((String) command.subSequence(0, 3)); \t\ttry { \t\t\tswitch(num){ \t\t\tcase 148: \t\t\t\tout.write(getIndication()); \t\t\t\tout.write(\"\\n\"); \t\t\t\tout.flush(); \t\t\t\tbreak; \t\t\tdefault: \t\t\t\tsuper.command(command, out); \t\t\t\tbreak; \t\t\t} \t\t}catch (IOException ioe) { \t\t\tioe.printStackTrace(); \t\t} \t} \t \tpublic char getIndication() {  \t\tif (isOverMessage()) {  \t\t\treturn readMessage().charAt(0);  \t\t} else {  \t\t\treturn ' ';  \t\t}  \t}  \tpublic void run() { $body \t} } ",
      "offset" : 1,
      "correction" : "$package \n\nimport java.io.BufferedWriter;\nimport java.io.IOException;\n\npublic class BDR extends plm.universe.bugglequest.AbstractBuggle {\n\t\n\t@Override\n\tpublic void command(String command, BufferedWriter out) {\n\t\tint num = Integer.parseInt((String) command.subSequence(0, 3));\n\t\ttry {\n\t\t\tswitch(num){\n\t\t\tcase 148:\n\t\t\t\tout.write(getIndication());\n\t\t\t\tout.write(\"\\n\");\n\t\t\t\tout.flush();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsuper.command(command, out);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}catch (IOException ioe) {\n\t\t\tioe.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic char getIndication() { \n\t\tif (isOverMessage()) { \n\t\t\treturn readMessage().charAt(0); \n\t\t} else { \n\t\t\treturn ' '; \n\t\t} \n\t}\n\n\tpublic void run() {\n\t\t/* BEGIN SOLUTION */\n\t\twhile (true) {\n\t\t\tchar c = getIndication();\n\n\t\t\tif (c == 'R') { \n\t\t\t\tright(); forward();\n\t\t\t} else if (c == 'L') {\n\t\t\t\tleft(); forward();\n\t\t\t} else if (c == 'I') {\n\t\t\t\tback(); forward(); \n\t\t\t} else if (c == 'A')\n\t\t\t\tforward();\n\t\t\telse if (c == 'B')\n\t\t\t\tforward(2);  \n\t\t\telse if (c == 'C')\n\t\t\t\tforward(3);\n\t\t\telse if (c == 'Z')\n\t\t\t\tbackward();\n\t\t\telse if (c == 'Y')\n\t\t\t\tbackward(2);  \n\t\t\telse if (c == 'X')\n\t\t\t\tbackward(3);\n\t\t\telse \n\t\t\t\treturn ;\n\t\t}\t\t\n\t\t/* END SOLUTION */\n\t}\n}\n",
      "error" : "Error"
    },
    "Scala" : {
      "name" : "BDR",
      "body" : "",
      "template" : "$package \n\nclass BDR extends plm.universe.bugglequest.SimpleBuggle {\n\toverride def run() {\n$body\n\t}\n}\n",
      "offset" : 4,
      "correction" : "$package \n\nclass BDR extends plm.universe.bugglequest.AbstractBuggle {\n\n\toverride def run() {\n\t\t/* BEGIN SOLUTION */\n\t    var done = false\n\t\twhile (!done) {\n\t\t\tvar c = readMessage()\n\n\t\t\tif (c == \"R\") { \n\t\t\t\tright(); forward();\n\t\t\t} else if (c == \"L\") {\n\t\t\t\tleft(); forward();\n\t\t\t} else if (c == \"I\") {\n\t\t\t\tback(); forward(); \n\t\t\t} else if (c == \"A\")\n\t\t\t\tforward();\n\t\t\telse if (c == \"B\")\n\t\t\t\tforward(2);  \n\t\t\telse if (c == \"C\")\n\t\t\t\tforward(3);\n\t\t\telse if (c == \"Z\")\n\t\t\t\tbackward();\n\t\t\telse if (c == \"Y\")\n\t\t\t\tbackward(2);  \n\t\t\telse if (c == \"X\")\n\t\t\t\tbackward(3);\n\t\t\telse \n\t\t\t\tdone = true ;\n\t\t}\t\t\n\t\t/* END SOLUTION */\n\t}\n}\n",
      "error" : "Error"
    },
    "Python" : {
      "name" : "BDR",
      "body" : "",
      "template" : "$body\n",
      "offset" : 1,
      "correction" : "# BEGIN SOLUTION\ndone = False\nwhile not done:\n    c = readMessage()\n    if c == 'R':\n        right()\n        forward()\n    elif c == 'L':\n        left()\n        forward()\n    elif c == 'I':\n        back()\n        forward()\n    elif c == 'A':\n        forward()\n    elif c == 'B':\n        forward(2)\n    elif c == 'C':\n        forward(3)\n    elif c == 'Z':\n        backward()\n    elif c == 'Y':\n        backward(2)\n    elif c == 'X':\n        backward(3)\n    else:        \n        done = True\n# END SOLUTION\n",
      "error" : "Error"
    }
  },
  "helps" : {
    "pt" : "<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->\n<h1>BuggleWorld</h1>\nThis world was invented by Lyn Turbak, at Wellesley College. It is full of\nBuggles, little animals understanding simple orders, and offers numerous\npossibilities of interaction with the world: taking or dropping objects,\npaint the ground, hit walls, etc.\n\n<h2>Methods understood by buggles</h2>\n<table border=1>\n<tr><td colspan=2 align=center><b>Moving</b><br/> (See also the note on exceptions, below)</td></tr>\n  <tr><td><b>Turn left<br/>Turn right<br/>Turn back<br/>Moving forward<br/>Moving back</b></td>\n      <td>[!java|c]void [/!]left()<br/>\n          [!java|c]void [/!]right()<br/>\n          [!java|c]void [/!]back()<br/>\n          [!java|c]void [/!][!python|java|scala]forward()[/!][!c]stepForward()[/!] or [!java|c]void [/!]forward([!java|c]int [/!]steps[!scala]:Int[/!])<br/>\n          [!java|c]void [/!][!python|java|scala]backward()[/!][!c]stepBackward()[/!] or [!java]void [/!]backward([!java|c]int [/!]steps[!scala]:Int[/!])<br/></td></tr>\n  <tr><td><b>Get X coordinate<br/>Get Y coordinate<br/>Set X coordinate<br/>Set Y coordinate<br/>Set position</b></td>\n      <td>[!java|c]int [/!]getX()[!scala]:Int[/!]<br/>\n          [!java|c]int [/!]getY()[!scala]:Int[/!]<br/>\n          [!java|c]void [/!]setX([!java|c]int [/!]x[!scala]:Int[/!])<br/>\n          [!java|c]void [/!]setY([!java|c]int [/!]y[!scala]:Int[/!])<br/>\n          [!java|c]void [/!]setPos([!java|c]int [/!]x[!scala]:Int[/!], [!java|c]int [/!]y[!scala]:Int[/!])</td></tr>\n<tr><td colspan=2>Note that the point (0,0) is on the top left corner, as it is often the case in Computer Science.</td></tr>\n\n<tr><td colspan=2 align=center><b>Information on the buggle</b></td></tr>\n  <tr><td><b>Get the color of the body<br/>Set the color of the body</b></td>\n      <td>[!java|c]Color [/!]getBodyColor()[!scala]:Color[/!]<br/>\n          [!java|c]void [/!]setBodyColor([!java|c]Color [/!]c[!scala]:Color[/!])</td></tr>\t\t\t\t\n  <tr><td><b>Look for a wall forward<br/>Look for a wall backward</b></td>\n      <td>[!java]boolean [/!][!c]int [/!]isFacingWall()[!scala]:Boolean[/!]<br/>\n          [!java]boolean [/!][!c]int [/!]isBackingWall()[!scala]:Boolean[/!]</td></tr>\t\t\t\t\n  <tr><td><b>Get heading<br/>Set heading</b><br/>valid directions are:</td>\n      <td>[!java|c]Direction [/!]getDirection()[!scala]:Direction[/!]<br/>\n          [!java|c]void [/!]setDirection([!java|c]Direction [/!]dir[!scala]:Direction[/!])<br/>\n          [!scala|java|python]Direction.[/!]NORTH, [!scala|java|python]Direction.[/!]EAST, [!scala|java|python]Direction.[/!]SOUTH and [!scala|java|python]Direction.[/!]WEST</td></tr>\n  <tr><td>Check whether the buggle is currently <b>selected in the interface</b></td>\n      <td>[!java]boolean [/!][!c]int [/!]isSelected()[!scala]:Boolean[/!]</td></tr>\n \n<tr><td colspan=2 align=center><b>About the brush</b></td></tr>\n  <tr><td><b>Brush down<br/>Brush up<br/>Get brush position</b></td>\n      <td>[!java|c]void [/!]brushUp()<br/>\n          [!java|c]void [/!]brushDown()<br/>\n          [!java]boolean [/!][!c]int [/!]isBrushDown()[!scala]:Boolean[/!]</td></tr>\n  <tr><td><b>Change the brush color<br/>Get the color of the brush</b></td>\n      <td>[!java|c]void [/!]setBrushColor([!java|c]Color [/!]c[!scala]:Color[/!])<br/>\n          [!java|c]Color [/!]getBrushColor()[!scala]:Color[/!]</td></tr>\n\n<tr><td colspan=2 align=center><b>Interacting with the world</b></td></tr>\n  <tr><td><b>Get the color of the ground</b></td>\n      <td>[!java|c]Color [/!]getGroundColor()[!scala]:Color[/!]</td></tr>\n\n  <tr><td><b>Look for a baggle on the ground<br/>Look for a baggle in bag<br/>Pickup a baggle<br/>Drop a baggle</b><br/>\n      (see the note on exceptions)</td>\n      <td>[!java]boolean [/!][!c]int [/!]isOverBaggle()[!scala]:Boolean[/!]<br/>\n          [!java]boolean [/!][!c]int [/!]isCarryingBaggle()[!scala]:Boolean[/!]<br/>\n          [!java]void [/!]pickupBaggle()<br/>\n          [!java]void [/!]dropBaggle()<br/>\n          &nbsp;</td></tr>\n\n  <tr><td><b>Look for a message<br/>Add a message<br/>Read the message<br/>Erase the message</b></td>\n      <td>[!java]boolean [/!][!c]int [/!]isOverMessage()[!scala]:Boolean[/!]<br/>\n          [!java]void [/!]writeMessage([!java]String [/!][!c]char* [/!]msg[!scala]:String[/!])<br/>\n          [!java]String [/!][!c]char* [/!]readMessage()[!scala]:String[/!]<br/>\n          [!java]void [/!]clearMessage()</td></tr>\n</table>\n\n<h2>Valid colors</h2>\n<table border=1>\n<tr><td>Name</td><td>Color</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]black</td>    <td BGCOLOR=\"#000000\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]blue</td>     <td BGCOLOR=\"#0000FF\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]cyan</td>     <td BGCOLOR=\"#00FFFF\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]darkGray</td> <td BGCOLOR=\"#404040\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]gray</td>     <td BGCOLOR=\"#808080\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]green</td>    <td BGCOLOR=\"#00FF00\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]lightGray</td><td BGCOLOR=\"#C0C0C0\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]magenta</td>  <td BGCOLOR=\"#FF00FF\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]orange</td>   <td BGCOLOR=\"#FFC800\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]pink</td>     <td BGCOLOR=\"#FFAFAF\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]red</td>      <td BGCOLOR=\"#FF0000\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]white</td>    <td BGCOLOR=\"#FFFFFF\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]yellow</td>   <td BGCOLOR=\"#FFFF00\">&nbsp;</td></tr>\n</table>\n\n<h2>Note on exceptions</h2>\nRegular buggles throw a BuggleWallException exception if you ask them to\ntraverse a wall.  They throw a NoBaggleUnderBuggleException exception if you\nask them to pickup a baggle from an empty cell, or a\nAlreadyHaveBaggleException exception if they already carry a baggle.  Trying\nto drop a baggle on a cell already containing one throws an\nAlreadyHaveBaggleException exception. \nDropping a baggle when you have none throws a DontHaveBaggleException.\n<p>SimpleBuggles (ie, the one used in first exercises) display an error message\non problem so that you don't need to know what an exception is.</p>\n",
    "en" : "<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->\n<h1>BuggleWorld</h1>\nThis world was invented by Lyn Turbak, at Wellesley College. It is full of\nBuggles, little animals understanding simple orders, and offers numerous\npossibilities of interaction with the world: taking or dropping objects,\npaint the ground, hit walls, etc.\n\n<h2>Methods understood by buggles</h2>\n<table border=1>\n<tr><td colspan=2 align=center><b>Moving</b><br/> (See also the note on exceptions, below)</td></tr>\n  <tr><td><b>Turn left<br/>Turn right<br/>Turn back<br/>Moving forward<br/>Moving back</b></td>\n      <td>[!java|c]void [/!]left()<br/>\n          [!java|c]void [/!]right()<br/>\n          [!java|c]void [/!]back()<br/>\n          [!java|c]void [/!][!python|java|scala]forward()[/!][!c]stepForward()[/!] or [!java|c]void [/!]forward([!java|c]int [/!]steps[!scala]:Int[/!])<br/>\n          [!java|c]void [/!][!python|java|scala]backward()[/!][!c]stepBackward()[/!] or [!java]void [/!]backward([!java|c]int [/!]steps[!scala]:Int[/!])<br/></td></tr>\n  <tr><td><b>Get X coordinate<br/>Get Y coordinate<br/>Set X coordinate<br/>Set Y coordinate<br/>Set position</b></td>\n      <td>[!java|c]int [/!]getX()[!scala]:Int[/!]<br/>\n          [!java|c]int [/!]getY()[!scala]:Int[/!]<br/>\n          [!java|c]void [/!]setX([!java|c]int [/!]x[!scala]:Int[/!])<br/>\n          [!java|c]void [/!]setY([!java|c]int [/!]y[!scala]:Int[/!])<br/>\n          [!java|c]void [/!]setPos([!java|c]int [/!]x[!scala]:Int[/!], [!java|c]int [/!]y[!scala]:Int[/!])</td></tr>\n<tr><td colspan=2>Note that the point (0,0) is on the top left corner, as it is often the case in Computer Science.</td></tr>\n\n<tr><td colspan=2 align=center><b>Information on the buggle</b></td></tr>\n  <tr><td><b>Get the color of the body<br/>Set the color of the body</b></td>\n      <td>[!java|c]Color [/!]getBodyColor()[!scala]:Color[/!]<br/>\n          [!java|c]void [/!]setBodyColor([!java|c]Color [/!]c[!scala]:Color[/!])</td></tr>\t\t\t\t\n  <tr><td><b>Look for a wall forward<br/>Look for a wall backward</b></td>\n      <td>[!java]boolean [/!][!c]int [/!]isFacingWall()[!scala]:Boolean[/!]<br/>\n          [!java]boolean [/!][!c]int [/!]isBackingWall()[!scala]:Boolean[/!]</td></tr>\t\t\t\t\n  <tr><td><b>Get heading<br/>Set heading</b><br/>valid directions are:</td>\n      <td>[!java|c]Direction [/!]getDirection()[!scala]:Direction[/!]<br/>\n          [!java|c]void [/!]setDirection([!java|c]Direction [/!]dir[!scala]:Direction[/!])<br/>\n          [!scala|java|python]Direction.[/!]NORTH, [!scala|java|python]Direction.[/!]EAST, [!scala|java|python]Direction.[/!]SOUTH and [!scala|java|python]Direction.[/!]WEST</td></tr>\n  <tr><td>Check whether the buggle is currently <b>selected in the interface</b></td>\n      <td>[!java]boolean [/!][!c]int [/!]isSelected()[!scala]:Boolean[/!]</td></tr>\n \n<tr><td colspan=2 align=center><b>About the brush</b></td></tr>\n  <tr><td><b>Brush down<br/>Brush up<br/>Get brush position</b></td>\n      <td>[!java|c]void [/!]brushUp()<br/>\n          [!java|c]void [/!]brushDown()<br/>\n          [!java]boolean [/!][!c]int [/!]isBrushDown()[!scala]:Boolean[/!]</td></tr>\n  <tr><td><b>Change the brush color<br/>Get the color of the brush</b></td>\n      <td>[!java|c]void [/!]setBrushColor([!java|c]Color [/!]c[!scala]:Color[/!])<br/>\n          [!java|c]Color [/!]getBrushColor()[!scala]:Color[/!]</td></tr>\n\n<tr><td colspan=2 align=center><b>Interacting with the world</b></td></tr>\n  <tr><td><b>Get the color of the ground</b></td>\n      <td>[!java|c]Color [/!]getGroundColor()[!scala]:Color[/!]</td></tr>\n\n  <tr><td><b>Look for a baggle on the ground<br/>Look for a baggle in bag<br/>Pickup a baggle<br/>Drop a baggle</b><br/>\n      (see the note on exceptions)</td>\n      <td>[!java]boolean [/!][!c]int [/!]isOverBaggle()[!scala]:Boolean[/!]<br/>\n          [!java]boolean [/!][!c]int [/!]isCarryingBaggle()[!scala]:Boolean[/!]<br/>\n          [!java]void [/!]pickupBaggle()<br/>\n          [!java]void [/!]dropBaggle()<br/>\n          &nbsp;</td></tr>\n\n  <tr><td><b>Look for a message<br/>Add a message<br/>Read the message<br/>Erase the message</b></td>\n      <td>[!java]boolean [/!][!c]int [/!]isOverMessage()[!scala]:Boolean[/!]<br/>\n          [!java]void [/!]writeMessage([!java]String [/!][!c]char* [/!]msg[!scala]:String[/!])<br/>\n          [!java]String [/!][!c]char* [/!]readMessage()[!scala]:String[/!]<br/>\n          [!java]void [/!]clearMessage()</td></tr>\n</table>\n\n<h2>Valid colors</h2>\n<table border=1>\n<tr><td>Name</td><td>Color</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]black</td>    <td BGCOLOR=\"#000000\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]blue</td>     <td BGCOLOR=\"#0000FF\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]cyan</td>     <td BGCOLOR=\"#00FFFF\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]darkGray</td> <td BGCOLOR=\"#404040\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]gray</td>     <td BGCOLOR=\"#808080\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]green</td>    <td BGCOLOR=\"#00FF00\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]lightGray</td><td BGCOLOR=\"#C0C0C0\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]magenta</td>  <td BGCOLOR=\"#FF00FF\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]orange</td>   <td BGCOLOR=\"#FFC800\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]pink</td>     <td BGCOLOR=\"#FFAFAF\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]red</td>      <td BGCOLOR=\"#FF0000\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]white</td>    <td BGCOLOR=\"#FFFFFF\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]yellow</td>   <td BGCOLOR=\"#FFFF00\">&nbsp;</td></tr>\n</table>\n\n<h2>Note on exceptions</h2>\nRegular buggles throw a BuggleWallException exception if you ask them to\ntraverse a wall.  They throw a NoBaggleUnderBuggleException exception if you\nask them to pickup a baggle from an empty cell, or a\nAlreadyHaveBaggleException exception if they already carry a baggle.  Trying\nto drop a baggle on a cell already containing one throws an\nAlreadyHaveBaggleException exception. \nDropping a baggle when you have none throws a DontHaveBaggleException.\n<p>SimpleBuggles (ie, the one used in first exercises) display an error message\non problem so that you don't need to know what an exception is.</p>\n",
    "fr" : "\n<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->\n<h1>Le monde des Buggles</h1>\nCe monde a été inventé par Lyn Turbak, du Wellesley College. Il est peuplé\nde Buggles, petites bêtes qui comprennent des ordres simples, et offre de\nnombreuses possibilités d'interaction avec le monde : prendre ou poser des\nobjets, colorier le sol, se cogner à des murs, etc.\n\n<h2>Méthodes comprises par les buggles</h2>\n<table border=1>\n<tr><td colspan=2 align=center><b>Bouger</b><br/> (voir aussi la note sur les exceptions, plus bas)</td></tr>\n  <tr><td><b>Tourner à gauche<br/>Tourner à droite<br/>Se retourner<br/>Avancer<br/>Reculer</b></td>\n      <td>[!java|c]void [/!]gauche()<br/>\n          [!java|c]void [/!]droite()<br/>\n          [!java|c]void [/!]retourne()<br/>\n          [!java|c]void [/!][!python|java|scala]avance()[/!][!c]avancePas()[/!] or\n[!java|c]void [/!]avance([!java|c]int [/!]nbPas[!scala]:Int[/!])<br/>\n          [!java|c]void [/!][!python|java|scala]recule()[/!][!c]reculePas()[/!] or\n[!java]void [/!]recule([!java|c]int [/!]nbPas[!scala]:Int[/!])<br/></td></tr>\n  <tr><td><b>Obtenir l'abscisse<br/>Obtenir l'ordonnée<br/>Changer l'abscisse<br/>Changer l'ordonnée<br/>Changer la position</b></td>\n      <td>[!java|c]int [/!]getX()[!scala]:Int[/!]<br/>\n          [!java|c]int [/!]getY()[!scala]:Int[/!]<br/>\n          [!java|c]void [/!]setX([!java|c]int [/!]x[!scala]:Int[/!])<br/>\n          [!java|c]void [/!]setY([!java|c]int [/!]y[!scala]:Int[/!])<br/>\n          [!java|c]void [/!]setPos([!java|c]int [/!]x[!scala]:Int[/!], [!java|c]int\n[/!]y[!scala]:Int[/!])</td></tr>\n<tr><td colspan=2>L'origine (0, 0) est dans le coin en haut à gauche, comme c'est souvent le\ncas en informatique.</td></tr>\n\n<tr><td colspan=2 align=center><b>Informations sur la buggle</b></td></tr>\n  <tr><td><b>Obtenir la couleur de la buggle</b><br/>Changer la couleur de la buggle</b></td>\n      <td>[!java|c]Color [/!]getCouleurCorps()[!scala]:Color[/!]<br/>\n          [!java|c]void [/!]setCouleurCorps([!java|c]Color [/!]c[!scala]:Color[/!])</td></tr>\t\t\t\t\n  <tr><td><b>Chercher un mur devant<br/>Chercher un mur derrière</b></td>\n      <td>[!java]boolean [/!][!c]int [/!]estFaceMur()[!scala]:Boolean[/!]<br/>\n          [!java]boolean [/!][!c]int [/!]estDosMur()[!scala]:Boolean[/!]</td></tr>\t\t\t\t\n  <tr><td><b>Obtenir la direction<br/>Changer la direction</b><br/>Les directions valides sont :</td>\n      <td>[!java|c]Direction [/!]getDirection()[!scala]:Direction[/!]<br/>\n          [!java|c]void [/!]setDirection([!java|c]Direction\n[/!]dir[!scala]:Direction[/!])<br/>\n          [!scala|java|python]Direction.[/!]NORTH (nord),\n[!scala|java|python]Direction.[/!]EAST (est),\n[!scala|java|python]Direction.[/!]SOUTH (sud) et\n[!scala|java|python]Direction.[/!]WEST (ouest)</td></tr>\n  <tr><td>Renvoi si la buggle est actuellement <b>sélectionnée dans l'interface</b></td>\n      <td>[!java]boolean [/!][!c]int [/!]estChoisie()[!scala]:Boolean[/!]</td></tr>\n \n<tr><td colspan=2 align=center><b>À propos de la brosse</b></td></tr>\n  <tr><td><b>Baisser la brosse<br/>Lever la brosse<br/>Obtenir la position de la brosse</b></td>\n      <td>[!java|c]void [/!]leveBrosse()<br/>\n          [!java|c]void [/!]baisseBrosse()<br/>\n          [!java]boolean [/!][!c]int [/!]estBrosseBaissee()[!scala]:Boolean[/!]</td></tr>\n  <tr><td><b>Modifier la couleur de la brosse<br/>Obtenir la couleur de la brosse</b></td>\n      <td>[!java|c]void [/!]setCouleurBrosse([!java|c]Color [/!]c[!scala]:Color[/!])<br/>\n          [!java|c]Color [/!]getCouleurBrosse()[!scala]:Color[/!]</td></tr>\n\n<tr><td colspan=2 align=center><b>Interagir avec le monde</b></td></tr>\n  <tr><td><b>Obtenir la couleur du sol</b></td>\n      <td>[!java|c]Color [/!]getCouleurSol()[!scala]:Color[/!]</td></tr>\n\n  <tr><td><b>Vrai si biscuit par terre<br/>Vrai si on porte un biscuit<br/>Ramasse un biscuit<br/>Poser un biscuit</b><br/>\n      (voir la note sur les exceptions)</td>\n      <td>[!java]boolean [/!][!c]int [/!]estSurBiscuit()[!scala]:Boolean[/!]<br/>\n          [!java]boolean [/!][!c]int [/!]porteBiscuit()[!scala]:Boolean[/!]<br/>\n          [!java]void [/!]prendBiscuit()<br/>\n          [!java]void [/!]poseBiscuit()<br/>\n          &nbsp;</td></tr>\n\n  <tr><td><b>Chercher un message<br/>Ajouter un message<br/>Lire le message<br/>Effacer le message</b></td>\n      <td>[!java]boolean [/!][!c]int [/!]estSurMessage()[!scala]:Boolean[/!]<br/>\n          [!java]void [/!]ecritMessage([!java]String [/!][!c]char*\n[/!]msg[!scala]:String[/!])<br/>\n          [!java]String [/!][!c]char* [/!]litMessage()[!scala]:String[/!]<br/>\n          [!java]void [/!]effaceMessage()</td></tr>\n</table>\n\n<h2>Couleurs valides</h2>\n<table border=1>\n<tr><td>Nom</td><td>Couleur</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]black</td>    <td BGCOLOR=\"#000000\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]blue</td>     <td BGCOLOR=\"#0000FF\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]cyan</td>     <td BGCOLOR=\"#00FFFF\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]darkGray</td> <td BGCOLOR=\"#404040\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]gray</td>     <td BGCOLOR=\"#808080\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]green</td>    <td BGCOLOR=\"#00FF00\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]lightGray</td><td BGCOLOR=\"#C0C0C0\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]magenta</td>  <td BGCOLOR=\"#FF00FF\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]orange</td>   <td BGCOLOR=\"#FFC800\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]pink</td>     <td BGCOLOR=\"#FFAFAF\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]red</td>      <td BGCOLOR=\"#FF0000\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]white</td>    <td BGCOLOR=\"#FFFFFF\">&nbsp;</td></tr>\n<tr><td>[!scala|java|python]Color.[/!]yellow</td>   <td BGCOLOR=\"#FFFF00\">&nbsp;</td></tr>\n</table>\n\n<h2>Note sur les exceptions</h2>\nLes buggles normales lèvent une exception BuggleWallException si on cherche\nà leur faire traverser un mur.\nElles lèvent une exception NoBaggleUnderBuggleException si vous cherchez à\nprendre un biscuit dans une case qui n'en contient pas, ou une exception\nAlreadyHaveBaggleException si vous portez déjà un biscuit.\nTenter de déposer un biscuit sur une case qui en contient déjà lève une\nexception AlreadyHaveBaggleException.\nTenter de poser un biscuit alors qu'on n'en a pas lève une exception\nDontHaveBaggleException.\n<p>Les \"SimpleBuggles\" (c.-à-d., celles utilisées dans les premiers exercices)\naffichent un message d'erreur sans que vous ayez à vous soucier de ce qu'est\nune exception.</p>\n"
  },
  "initialWorlds" : [ {
    "type" : "plm.universe.bugglequest.BuggleWorld",
    "@jsonId" : 1,
    "name" : "Dance Floor",
    "width" : 7,
    "height" : 7,
    "entities" : [ {
      "type" : "plm.universe.bugglequest.SimpleBuggle",
      "name" : "John Travolta",
      "x" : 0,
      "y" : 6,
      "direction" : 1,
      "bodyColor" : [ 255, 0, 0, 255 ],
      "brushColor" : [ 192, 192, 192, 255 ],
      "world" : 1,
      "inited" : false,
      "brushDown" : false
    }, {
      "type" : "plm.universe.bugglequest.SimpleBuggle",
      "name" : "Break Dancer",
      "x" : 0,
      "y" : 0,
      "direction" : 3,
      "bodyColor" : [ 255, 0, 255, 255 ],
      "brushColor" : [ 192, 192, 192, 255 ],
      "world" : 1,
      "inited" : false,
      "brushDown" : false
    }, {
      "type" : "plm.universe.bugglequest.SimpleBuggle",
      "name" : "Moon Walker",
      "x" : 6,
      "y" : 0,
      "direction" : 3,
      "bodyColor" : [ 255, 175, 175, 255 ],
      "brushColor" : [ 192, 192, 192, 255 ],
      "world" : 1,
      "inited" : false,
      "brushDown" : false
    }, {
      "type" : "plm.universe.bugglequest.SimpleBuggle",
      "name" : "Elwood Blues",
      "x" : 6,
      "y" : 6,
      "direction" : 3,
      "bodyColor" : [ 0, 0, 255, 255 ],
      "brushColor" : [ 192, 192, 192, 255 ],
      "world" : 1,
      "inited" : false,
      "brushDown" : false
    } ],
    "steps" : [ ],
    "about" : "<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->\n<h1>BuggleWorld</h1>\nThis world was invented by Lyn Turbak, at Wellesley College. It is full of\nBuggles, little animals understanding simple orders, and offers numerous\npossibilities of interaction with the world: taking or dropping objects,\npaint the ground, hit walls, etc.\n\n<h2>Methods understood by buggles</h2>\n<table border=1>\n<tr><td colspan=2 align=center><b>Moving</b><br/> (See also the note on exceptions, below)</td></tr>\n  <tr><td><b>Turn left<br/>Turn right<br/>Turn back<br/>Moving forward<br/>Moving back</b></td>\n      <td>void left()<br/>\n          void right()<br/>\n          void back()<br/>\n          void forward() or void forward(int steps)<br/>\n          void backward() or void backward(int steps)<br/></td></tr>\n  <tr><td><b>Get X coordinate<br/>Get Y coordinate<br/>Set X coordinate<br/>Set Y coordinate<br/>Set position</b></td>\n      <td>int getX()<br/>\n          int getY()<br/>\n          void setX(int x)<br/>\n          void setY(int y)<br/>\n          void setPos(int x, int y)</td></tr>\n<tr><td colspan=2>Note that the point (0,0) is on the top left corner, as it is often the case in Computer Science.</td></tr>\n\n<tr><td colspan=2 align=center><b>Information on the buggle</b></td></tr>\n  <tr><td><b>Get the color of the body<br/>Set the color of the body</b></td>\n      <td>Color getBodyColor()<br/>\n          void setBodyColor(Color c)</td></tr>\t\t\t\t\n  <tr><td><b>Look for a wall forward<br/>Look for a wall backward</b></td>\n      <td>boolean isFacingWall()<br/>\n          boolean isBackingWall()</td></tr>\t\t\t\t\n  <tr><td><b>Get heading<br/>Set heading</b><br/>valid directions are:</td>\n      <td>Direction getDirection()<br/>\n          void setDirection(Direction dir)<br/>\n          Direction.NORTH, Direction.EAST, Direction.SOUTH and Direction.WEST</td></tr>\n  <tr><td>Check whether the buggle is currently <b>selected in the interface</b></td>\n      <td>boolean isSelected()</td></tr>\n \n<tr><td colspan=2 align=center><b>About the brush</b></td></tr>\n  <tr><td><b>Brush down<br/>Brush up<br/>Get brush position</b></td>\n      <td>void brushUp()<br/>\n          void brushDown()<br/>\n          boolean isBrushDown()</td></tr>\n  <tr><td><b>Change the brush color<br/>Get the color of the brush</b></td>\n      <td>void setBrushColor(Color c)<br/>\n          Color getBrushColor()</td></tr>\n\n<tr><td colspan=2 align=center><b>Interacting with the world</b></td></tr>\n  <tr><td><b>Get the color of the ground</b></td>\n      <td>Color getGroundColor()</td></tr>\n\n  <tr><td><b>Look for a baggle on the ground<br/>Look for a baggle in bag<br/>Pickup a baggle<br/>Drop a baggle</b><br/>\n      (see the note on exceptions)</td>\n      <td>boolean isOverBaggle()<br/>\n          boolean isCarryingBaggle()<br/>\n          void pickupBaggle()<br/>\n          void dropBaggle()<br/>\n          &nbsp;</td></tr>\n\n  <tr><td><b>Look for a message<br/>Add a message<br/>Read the message<br/>Erase the message</b></td>\n      <td>boolean isOverMessage()<br/>\n          void writeMessage(String msg)<br/>\n          String readMessage()<br/>\n          void clearMessage()</td></tr>\n</table>\n\n<h2>Valid colors</h2>\n<table border=1>\n<tr><td>Name</td><td>Color</td></tr>\n<tr><td>Color.black</td>    <td BGCOLOR=\"#000000\">&nbsp;</td></tr>\n<tr><td>Color.blue</td>     <td BGCOLOR=\"#0000FF\">&nbsp;</td></tr>\n<tr><td>Color.cyan</td>     <td BGCOLOR=\"#00FFFF\">&nbsp;</td></tr>\n<tr><td>Color.darkGray</td> <td BGCOLOR=\"#404040\">&nbsp;</td></tr>\n<tr><td>Color.gray</td>     <td BGCOLOR=\"#808080\">&nbsp;</td></tr>\n<tr><td>Color.green</td>    <td BGCOLOR=\"#00FF00\">&nbsp;</td></tr>\n<tr><td>Color.lightGray</td><td BGCOLOR=\"#C0C0C0\">&nbsp;</td></tr>\n<tr><td>Color.magenta</td>  <td BGCOLOR=\"#FF00FF\">&nbsp;</td></tr>\n<tr><td>Color.orange</td>   <td BGCOLOR=\"#FFC800\">&nbsp;</td></tr>\n<tr><td>Color.pink</td>     <td BGCOLOR=\"#FFAFAF\">&nbsp;</td></tr>\n<tr><td>Color.red</td>      <td BGCOLOR=\"#FF0000\">&nbsp;</td></tr>\n<tr><td>Color.white</td>    <td BGCOLOR=\"#FFFFFF\">&nbsp;</td></tr>\n<tr><td>Color.yellow</td>   <td BGCOLOR=\"#FFFF00\">&nbsp;</td></tr>\n</table>\n\n<h2>Note on exceptions</h2>\nRegular buggles throw a BuggleWallException exception if you ask them to\ntraverse a wall.  They throw a NoBaggleUnderBuggleException exception if you\nask them to pickup a baggle from an empty cell, or a\nAlreadyHaveBaggleException exception if they already carry a baggle.  Trying\nto drop a baggle on a cell already containing one throws an\nAlreadyHaveBaggleException exception. \nDropping a baggle when you have none throws a DontHaveBaggleException.\n<p>SimpleBuggles (ie, the one used in first exercises) display an error message\non problem so that you don't need to know what an exception is.</p>\n",
    "parameters" : null,
    "cells" : [ [ {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 0,
      "y" : 0,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "Z"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 0,
      "y" : 1
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 0,
      "y" : 2
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 0,
      "y" : 3,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "X"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 0,
      "y" : 4
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 0,
      "y" : 5
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 0,
      "y" : 6,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "A"
    } ], [ {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 1,
      "y" : 0,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "L"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 1,
      "y" : 1,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "B"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 1,
      "y" : 2
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 1,
      "y" : 3,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "R"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 1,
      "y" : 4
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 1,
      "y" : 5,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "B"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 1,
      "y" : 6,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "L"
    } ], [ {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 2,
      "y" : 0
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 2,
      "y" : 1
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 2,
      "y" : 2
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 2,
      "y" : 3
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 2,
      "y" : 4
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 2,
      "y" : 5
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 2,
      "y" : 6,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "Z"
    } ], [ {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 3,
      "y" : 0,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "L"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 3,
      "y" : 1,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "B"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 3,
      "y" : 2
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 3,
      "y" : 3,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "Z"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 3,
      "y" : 4
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 3,
      "y" : 5,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "B"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 3,
      "y" : 6,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "R"
    } ], [ {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 4,
      "y" : 0,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "A"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 4,
      "y" : 1
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 4,
      "y" : 2
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 4,
      "y" : 3
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 4,
      "y" : 4
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 4,
      "y" : 5
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 4,
      "y" : 6,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "B"
    } ], [ {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 5,
      "y" : 0,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "L"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 5,
      "y" : 1,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "B"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 5,
      "y" : 2,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "B"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 5,
      "y" : 3,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "I"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 5,
      "y" : 4,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "B"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 5,
      "y" : 5,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "B"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 5,
      "y" : 6,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "R"
    } ], [ {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 6,
      "y" : 0,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "A"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 6,
      "y" : 1
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 6,
      "y" : 2
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 6,
      "y" : 3
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 6,
      "y" : 4
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 6,
      "y" : 5
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 1,
      "x" : 6,
      "y" : 6,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "A"
    } ] ],
    "visibleGrid" : true,
    "easter" : false
  } ],
  "answerWorlds" : [ {
    "type" : "plm.universe.bugglequest.BuggleWorld",
    "@jsonId" : 2,
    "name" : "Dance Floor",
    "width" : 7,
    "height" : 7,
    "entities" : [ {
      "type" : "plm.universe.bugglequest.SimpleBuggle",
      "name" : "John Travolta",
      "world" : 2,
      "inited" : true,
      "bodyColor" : [ 255, 0, 0, 255 ],
      "brushColor" : [ 192, 192, 192, 255 ],
      "x" : 2,
      "y" : 3,
      "direction" : 1,
      "brushDown" : false,
      "indication" : " "
    }, {
      "type" : "plm.universe.bugglequest.SimpleBuggle",
      "name" : "Break Dancer",
      "world" : 2,
      "inited" : true,
      "bodyColor" : [ 255, 0, 255, 255 ],
      "brushColor" : [ 192, 192, 192, 255 ],
      "x" : 4,
      "y" : 3,
      "direction" : 3,
      "brushDown" : false,
      "indication" : " "
    }, {
      "type" : "plm.universe.bugglequest.SimpleBuggle",
      "name" : "Moon Walker",
      "world" : 2,
      "inited" : true,
      "bodyColor" : [ 255, 175, 175, 255 ],
      "brushColor" : [ 192, 192, 192, 255 ],
      "x" : 3,
      "y" : 2,
      "direction" : 2,
      "brushDown" : false,
      "indication" : " "
    }, {
      "type" : "plm.universe.bugglequest.SimpleBuggle",
      "name" : "Elwood Blues",
      "world" : 2,
      "inited" : true,
      "bodyColor" : [ 0, 0, 255, 255 ],
      "brushColor" : [ 192, 192, 192, 255 ],
      "x" : 3,
      "y" : 4,
      "direction" : 0,
      "brushDown" : false,
      "indication" : " "
    } ],
    "steps" : [ [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 3,
      "buggleID" : "John Travolta",
      "oldX" : 0,
      "oldY" : 6,
      "newX" : 1,
      "newY" : 6,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.ChangeBuggleDirection",
      "@jsonId" : 4,
      "buggleID" : "John Travolta",
      "oldDirection" : 1,
      "newDirection" : 0,
      "name" : "changeBuggleDirection"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 5,
      "buggleID" : "John Travolta",
      "oldX" : 1,
      "oldY" : 6,
      "newX" : 1,
      "newY" : 5,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 6,
      "buggleID" : "John Travolta",
      "oldX" : 1,
      "oldY" : 5,
      "newX" : 1,
      "newY" : 4,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 7,
      "buggleID" : "John Travolta",
      "oldX" : 1,
      "oldY" : 4,
      "newX" : 1,
      "newY" : 3,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.ChangeBuggleDirection",
      "@jsonId" : 8,
      "buggleID" : "John Travolta",
      "oldDirection" : 0,
      "newDirection" : 1,
      "name" : "changeBuggleDirection"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 9,
      "buggleID" : "John Travolta",
      "oldX" : 1,
      "oldY" : 3,
      "newX" : 2,
      "newY" : 3,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 10,
      "buggleID" : "Break Dancer",
      "oldX" : 0,
      "oldY" : 0,
      "newX" : 1,
      "newY" : 0,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.ChangeBuggleDirection",
      "@jsonId" : 11,
      "buggleID" : "Break Dancer",
      "oldDirection" : 3,
      "newDirection" : 2,
      "name" : "changeBuggleDirection"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 12,
      "buggleID" : "Break Dancer",
      "oldX" : 1,
      "oldY" : 0,
      "newX" : 1,
      "newY" : 1,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 13,
      "buggleID" : "Break Dancer",
      "oldX" : 1,
      "oldY" : 1,
      "newX" : 1,
      "newY" : 2,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 14,
      "buggleID" : "Break Dancer",
      "oldX" : 1,
      "oldY" : 2,
      "newX" : 1,
      "newY" : 3,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.ChangeBuggleDirection",
      "@jsonId" : 15,
      "buggleID" : "Break Dancer",
      "oldDirection" : 2,
      "newDirection" : 3,
      "name" : "changeBuggleDirection"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 16,
      "buggleID" : "Break Dancer",
      "oldX" : 1,
      "oldY" : 3,
      "newX" : 0,
      "newY" : 3,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 17,
      "buggleID" : "Break Dancer",
      "oldX" : 0,
      "oldY" : 3,
      "newX" : 1,
      "newY" : 3,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 18,
      "buggleID" : "Break Dancer",
      "oldX" : 1,
      "oldY" : 3,
      "newX" : 2,
      "newY" : 3,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 19,
      "buggleID" : "Break Dancer",
      "oldX" : 2,
      "oldY" : 3,
      "newX" : 3,
      "newY" : 3,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 20,
      "buggleID" : "Break Dancer",
      "oldX" : 3,
      "oldY" : 3,
      "newX" : 4,
      "newY" : 3,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 21,
      "buggleID" : "Moon Walker",
      "oldX" : 6,
      "oldY" : 0,
      "newX" : 5,
      "newY" : 0,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.ChangeBuggleDirection",
      "@jsonId" : 22,
      "buggleID" : "Moon Walker",
      "oldDirection" : 3,
      "newDirection" : 2,
      "name" : "changeBuggleDirection"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 23,
      "buggleID" : "Moon Walker",
      "oldX" : 5,
      "oldY" : 0,
      "newX" : 5,
      "newY" : 1,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 24,
      "buggleID" : "Moon Walker",
      "oldX" : 5,
      "oldY" : 1,
      "newX" : 5,
      "newY" : 2,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 25,
      "buggleID" : "Moon Walker",
      "oldX" : 5,
      "oldY" : 2,
      "newX" : 5,
      "newY" : 3,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.ChangeBuggleDirection",
      "@jsonId" : 26,
      "buggleID" : "Moon Walker",
      "oldDirection" : 2,
      "newDirection" : 0,
      "name" : "changeBuggleDirection"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 27,
      "buggleID" : "Moon Walker",
      "oldX" : 5,
      "oldY" : 3,
      "newX" : 5,
      "newY" : 2,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 28,
      "buggleID" : "Moon Walker",
      "oldX" : 5,
      "oldY" : 2,
      "newX" : 5,
      "newY" : 1,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 29,
      "buggleID" : "Moon Walker",
      "oldX" : 5,
      "oldY" : 1,
      "newX" : 5,
      "newY" : 0,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 30,
      "buggleID" : "Elwood Blues",
      "oldX" : 6,
      "oldY" : 6,
      "newX" : 5,
      "newY" : 6,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.ChangeBuggleDirection",
      "@jsonId" : 31,
      "buggleID" : "Moon Walker",
      "oldDirection" : 0,
      "newDirection" : 3,
      "name" : "changeBuggleDirection"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 32,
      "buggleID" : "Moon Walker",
      "oldX" : 5,
      "oldY" : 0,
      "newX" : 4,
      "newY" : 0,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.ChangeBuggleDirection",
      "@jsonId" : 33,
      "buggleID" : "Elwood Blues",
      "oldDirection" : 3,
      "newDirection" : 0,
      "name" : "changeBuggleDirection"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 34,
      "buggleID" : "Elwood Blues",
      "oldX" : 5,
      "oldY" : 6,
      "newX" : 5,
      "newY" : 5,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 35,
      "buggleID" : "Elwood Blues",
      "oldX" : 5,
      "oldY" : 5,
      "newX" : 5,
      "newY" : 4,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 36,
      "buggleID" : "Elwood Blues",
      "oldX" : 5,
      "oldY" : 4,
      "newX" : 5,
      "newY" : 3,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.ChangeBuggleDirection",
      "@jsonId" : 37,
      "buggleID" : "Elwood Blues",
      "oldDirection" : 0,
      "newDirection" : 2,
      "name" : "changeBuggleDirection"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 38,
      "buggleID" : "Elwood Blues",
      "oldX" : 5,
      "oldY" : 3,
      "newX" : 5,
      "newY" : 4,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 39,
      "buggleID" : "Moon Walker",
      "oldX" : 4,
      "oldY" : 0,
      "newX" : 3,
      "newY" : 0,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.ChangeBuggleDirection",
      "@jsonId" : 40,
      "buggleID" : "Moon Walker",
      "oldDirection" : 3,
      "newDirection" : 2,
      "name" : "changeBuggleDirection"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 41,
      "buggleID" : "Elwood Blues",
      "oldX" : 5,
      "oldY" : 4,
      "newX" : 5,
      "newY" : 5,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 42,
      "buggleID" : "Moon Walker",
      "oldX" : 3,
      "oldY" : 0,
      "newX" : 3,
      "newY" : 1,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 43,
      "buggleID" : "Elwood Blues",
      "oldX" : 5,
      "oldY" : 5,
      "newX" : 5,
      "newY" : 6,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.ChangeBuggleDirection",
      "@jsonId" : 44,
      "buggleID" : "Elwood Blues",
      "oldDirection" : 2,
      "newDirection" : 3,
      "name" : "changeBuggleDirection"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 45,
      "buggleID" : "Elwood Blues",
      "oldX" : 5,
      "oldY" : 6,
      "newX" : 4,
      "newY" : 6,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 46,
      "buggleID" : "Moon Walker",
      "oldX" : 3,
      "oldY" : 1,
      "newX" : 3,
      "newY" : 2,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 47,
      "buggleID" : "Moon Walker",
      "oldX" : 3,
      "oldY" : 2,
      "newX" : 3,
      "newY" : 3,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 48,
      "buggleID" : "Elwood Blues",
      "oldX" : 4,
      "oldY" : 6,
      "newX" : 3,
      "newY" : 6,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 49,
      "buggleID" : "Elwood Blues",
      "oldX" : 3,
      "oldY" : 6,
      "newX" : 2,
      "newY" : 6,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 50,
      "buggleID" : "Moon Walker",
      "oldX" : 3,
      "oldY" : 3,
      "newX" : 3,
      "newY" : 2,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 51,
      "buggleID" : "Elwood Blues",
      "oldX" : 2,
      "oldY" : 6,
      "newX" : 3,
      "newY" : 6,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.ChangeBuggleDirection",
      "@jsonId" : 52,
      "buggleID" : "Elwood Blues",
      "oldDirection" : 3,
      "newDirection" : 0,
      "name" : "changeBuggleDirection"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 53,
      "buggleID" : "Elwood Blues",
      "oldX" : 3,
      "oldY" : 6,
      "newX" : 3,
      "newY" : 5,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 54,
      "buggleID" : "Elwood Blues",
      "oldX" : 3,
      "oldY" : 5,
      "newX" : 3,
      "newY" : 4,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 55,
      "buggleID" : "Elwood Blues",
      "oldX" : 3,
      "oldY" : 4,
      "newX" : 3,
      "newY" : 3,
      "name" : "moveBuggleOperation"
    } ], [ {
      "type" : "plm.universe.bugglequest.operations.MoveBuggleOperation",
      "@jsonId" : 56,
      "buggleID" : "Elwood Blues",
      "oldX" : 3,
      "oldY" : 3,
      "newX" : 3,
      "newY" : 4,
      "name" : "moveBuggleOperation"
    } ] ],
    "about" : "<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->\n<h1>BuggleWorld</h1>\nThis world was invented by Lyn Turbak, at Wellesley College. It is full of\nBuggles, little animals understanding simple orders, and offers numerous\npossibilities of interaction with the world: taking or dropping objects,\npaint the ground, hit walls, etc.\n\n<h2>Methods understood by buggles</h2>\n<table border=1>\n<tr><td colspan=2 align=center><b>Moving</b><br/> (See also the note on exceptions, below)</td></tr>\n  <tr><td><b>Turn left<br/>Turn right<br/>Turn back<br/>Moving forward<br/>Moving back</b></td>\n      <td>void left()<br/>\n          void right()<br/>\n          void back()<br/>\n          void forward() or void forward(int steps)<br/>\n          void backward() or void backward(int steps)<br/></td></tr>\n  <tr><td><b>Get X coordinate<br/>Get Y coordinate<br/>Set X coordinate<br/>Set Y coordinate<br/>Set position</b></td>\n      <td>int getX()<br/>\n          int getY()<br/>\n          void setX(int x)<br/>\n          void setY(int y)<br/>\n          void setPos(int x, int y)</td></tr>\n<tr><td colspan=2>Note that the point (0,0) is on the top left corner, as it is often the case in Computer Science.</td></tr>\n\n<tr><td colspan=2 align=center><b>Information on the buggle</b></td></tr>\n  <tr><td><b>Get the color of the body<br/>Set the color of the body</b></td>\n      <td>Color getBodyColor()<br/>\n          void setBodyColor(Color c)</td></tr>\t\t\t\t\n  <tr><td><b>Look for a wall forward<br/>Look for a wall backward</b></td>\n      <td>boolean isFacingWall()<br/>\n          boolean isBackingWall()</td></tr>\t\t\t\t\n  <tr><td><b>Get heading<br/>Set heading</b><br/>valid directions are:</td>\n      <td>Direction getDirection()<br/>\n          void setDirection(Direction dir)<br/>\n          Direction.NORTH, Direction.EAST, Direction.SOUTH and Direction.WEST</td></tr>\n  <tr><td>Check whether the buggle is currently <b>selected in the interface</b></td>\n      <td>boolean isSelected()</td></tr>\n \n<tr><td colspan=2 align=center><b>About the brush</b></td></tr>\n  <tr><td><b>Brush down<br/>Brush up<br/>Get brush position</b></td>\n      <td>void brushUp()<br/>\n          void brushDown()<br/>\n          boolean isBrushDown()</td></tr>\n  <tr><td><b>Change the brush color<br/>Get the color of the brush</b></td>\n      <td>void setBrushColor(Color c)<br/>\n          Color getBrushColor()</td></tr>\n\n<tr><td colspan=2 align=center><b>Interacting with the world</b></td></tr>\n  <tr><td><b>Get the color of the ground</b></td>\n      <td>Color getGroundColor()</td></tr>\n\n  <tr><td><b>Look for a baggle on the ground<br/>Look for a baggle in bag<br/>Pickup a baggle<br/>Drop a baggle</b><br/>\n      (see the note on exceptions)</td>\n      <td>boolean isOverBaggle()<br/>\n          boolean isCarryingBaggle()<br/>\n          void pickupBaggle()<br/>\n          void dropBaggle()<br/>\n          &nbsp;</td></tr>\n\n  <tr><td><b>Look for a message<br/>Add a message<br/>Read the message<br/>Erase the message</b></td>\n      <td>boolean isOverMessage()<br/>\n          void writeMessage(String msg)<br/>\n          String readMessage()<br/>\n          void clearMessage()</td></tr>\n</table>\n\n<h2>Valid colors</h2>\n<table border=1>\n<tr><td>Name</td><td>Color</td></tr>\n<tr><td>Color.black</td>    <td BGCOLOR=\"#000000\">&nbsp;</td></tr>\n<tr><td>Color.blue</td>     <td BGCOLOR=\"#0000FF\">&nbsp;</td></tr>\n<tr><td>Color.cyan</td>     <td BGCOLOR=\"#00FFFF\">&nbsp;</td></tr>\n<tr><td>Color.darkGray</td> <td BGCOLOR=\"#404040\">&nbsp;</td></tr>\n<tr><td>Color.gray</td>     <td BGCOLOR=\"#808080\">&nbsp;</td></tr>\n<tr><td>Color.green</td>    <td BGCOLOR=\"#00FF00\">&nbsp;</td></tr>\n<tr><td>Color.lightGray</td><td BGCOLOR=\"#C0C0C0\">&nbsp;</td></tr>\n<tr><td>Color.magenta</td>  <td BGCOLOR=\"#FF00FF\">&nbsp;</td></tr>\n<tr><td>Color.orange</td>   <td BGCOLOR=\"#FFC800\">&nbsp;</td></tr>\n<tr><td>Color.pink</td>     <td BGCOLOR=\"#FFAFAF\">&nbsp;</td></tr>\n<tr><td>Color.red</td>      <td BGCOLOR=\"#FF0000\">&nbsp;</td></tr>\n<tr><td>Color.white</td>    <td BGCOLOR=\"#FFFFFF\">&nbsp;</td></tr>\n<tr><td>Color.yellow</td>   <td BGCOLOR=\"#FFFF00\">&nbsp;</td></tr>\n</table>\n\n<h2>Note on exceptions</h2>\nRegular buggles throw a BuggleWallException exception if you ask them to\ntraverse a wall.  They throw a NoBaggleUnderBuggleException exception if you\nask them to pickup a baggle from an empty cell, or a\nAlreadyHaveBaggleException exception if they already carry a baggle.  Trying\nto drop a baggle on a cell already containing one throws an\nAlreadyHaveBaggleException exception. \nDropping a baggle when you have none throws a DontHaveBaggleException.\n<p>SimpleBuggles (ie, the one used in first exercises) display an error message\non problem so that you don't need to know what an exception is.</p>\n",
    "parameters" : null,
    "cells" : [ [ {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 0,
      "y" : 0,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "Z"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 0,
      "y" : 1
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 0,
      "y" : 2
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 0,
      "y" : 3,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "X"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 0,
      "y" : 4
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 0,
      "y" : 5
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 0,
      "y" : 6,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "A"
    } ], [ {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 1,
      "y" : 0,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "L"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 1,
      "y" : 1,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "B"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 1,
      "y" : 2
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 1,
      "y" : 3,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "R"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 1,
      "y" : 4
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 1,
      "y" : 5,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "B"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 1,
      "y" : 6,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "L"
    } ], [ {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 2,
      "y" : 0
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 2,
      "y" : 1
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 2,
      "y" : 2
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 2,
      "y" : 3
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 2,
      "y" : 4
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 2,
      "y" : 5
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 2,
      "y" : 6,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "Z"
    } ], [ {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 3,
      "y" : 0,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "L"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 3,
      "y" : 1,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "B"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 3,
      "y" : 2
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 3,
      "y" : 3,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "Z"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 3,
      "y" : 4
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 3,
      "y" : 5,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "B"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 3,
      "y" : 6,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "R"
    } ], [ {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 4,
      "y" : 0,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "A"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 4,
      "y" : 1
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 4,
      "y" : 2
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 4,
      "y" : 3
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 4,
      "y" : 4
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 4,
      "y" : 5
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 4,
      "y" : 6,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "B"
    } ], [ {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 5,
      "y" : 0,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "L"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 5,
      "y" : 1,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "B"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 5,
      "y" : 2,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "B"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 5,
      "y" : 3,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "I"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 5,
      "y" : 4,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "B"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 5,
      "y" : 5,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "B"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 5,
      "y" : 6,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "R"
    } ], [ {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 6,
      "y" : 0,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "A"
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 6,
      "y" : 1
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 6,
      "y" : 2
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 6,
      "y" : 3
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 6,
      "y" : 4
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 6,
      "y" : 5
    }, {
      "type" : "plm.universe.bugglequest.BuggleWorldCell",
      "world" : 2,
      "x" : 6,
      "y" : 6,
      "msgColor" : [ 128, 128, 230, 255 ],
      "content" : "A"
    } ] ],
    "visibleGrid" : true,
    "easter" : false
  } ],
  "instructions" : {
    "pt" : "\n<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->\n<h2>Buggle Dance Revolution (BDR)</h2>\n\n<p>Depois destas corridas, é hora de festejar! Para isto, vamos ensinar os\nbuggles a jogar Dance Revolution, este jogo amado por alguns estudantes: O\njogador tem que mover os pés num carpete de acordo com as instruções\napresentadas na tela, e seguir a música. Mas antes disto, temos alguns\ndetalhes para estudar primeiro.</p>\n\n[!java|scala|c]\n<h3>Condicionais sem colchetes</h3>\n<p>\nExiste um detalhe que nós omitimos sobre a sintaxe do condicional: se um\nramo contém apenas uma instrução, então o colchetes se torna\nopcional. Portanto, estes dois pedaços de código são equivalentes:</p>\n\n <pre><code class=\"code-container\">if (<b>condition</b>) {\n    <b>whatToDoIfTheConditionIsTrue();</b>\n} else {\n    <b>whatToDoElse();</b>\n}</code></pre>\n <pre><code class=\"code-container\">if (<b>condition</b>) \n    <b>whatToDoIfTheConditionIsTrue();</b>\nelse\n    <b>whatToDoElse();</b></code></pre>\n\n<p>Na verdade, você pode fazer o mesmo em corpos de loop que se reduzem a\napenas uma instrução. Mas cuidado, isto se torna perigoso se sua cadeia de\ninstruções <tt>if</tt> parece com isto: </p>\n<pre><code class=\"code-container\">if (isOverBaggle())    \n     if (x == 5)\n          left();\nelse\n     right();\n[!c]stepForward();[/!][!java|scala]forward();[/!]</code></pre>\n\n<p>De fato, não é para virar à direita quando não existe baggle no chão E x é\nigual a 5, mas quando o buggle encontra um baggle no chão e x é diferente de\n5. Colocando de outra forma, o buggle entende o código anterior como se ele\nfosse escrito da seguinte forma (note que o <tt>else</tt> foi movido para a\ndireita):</p>\n<pre><code class=\"code-container\">if (isOverBaggle())    \n        if (x == 5)\n            left();\n        else\n            right();\n[!c]stepForward();[/!][!java|scala]forward();[/!]</code></pre>\n\n<p>A primeira lição a tirar daí é que identação é muito importante para ajudar\nos humanos a entender, mesmo que não mude o significado do código. Nós\npoderíamos ter escrito o seguinte código e teríamos obtido o mesmo\nresultado. Mas se você quer que um humano leia e revise seu código, você vai\ncom certeza querer indentar ele corretamente. Este é o caso, por exemplo, se\nvocê quer que um professor leia ele (para dar nota ou tirar uma dúvida), ou\nse você quiser reutilizar seu código mais tarde, ou mesmo se você quiser\ndepurar você mesmo seu código.</p> \n\n<pre><code class=\"code-container\">if (isOverBaggle()) if (x == 5) left(); else right(); [!c]stepForward();[/!][!java|scala]forward();[/!]</code></pre>\n\n<p>A segunda lição é que o ramo do <tt>else</tt> sempre se conecta ao\n<tt>if</tt> mais próximo. Isto pode se tornar confuso em alguns casos, e\ntorna-se mais fácil adicionar mais chaves do que o estritamente necessário\npara remover quaisquer ambiguidades.</p>\n[/!]\n\n<h3>Encadeando condicionais</h3>\n\n<p>Algumas vezes você quer perguntar ao buggle algo similar a:</p> \n<pre><code class=\"code-container\">if it's raining, take an umbrella;\nif not, and if it's a hot day, take a bottle of water;\nif not and if it's July 4th, take an American flag</code></pre>\n\n<p>O armadilha é que nós queremos que pelo menos uma destas ações sejam\nfeitas.É como dizer, se está chovendo num 4 de Julho quente, não queremos\nque o buggle vá para fora com um guarda-chuva, água e um bandeira, mas\nsimplesmente com um guarda-chuva. O código seguinte está, então, ERRADO.</p>\n\n<pre><code class=\"code-container\">[!scala|c|java]if (rainy())\n    takeUmbrella();\nif (hot())\n    takeWater();\nif (todayIsJuly4th())\n    takeFlag();[/!][!python]if rainy():\n    takeUmbrella()\nif hot():\n    takeWater()\nif todayIsJuly4th():\n    takeFlag()[/!]</code></pre>\n\n\n<p>Na verdade, já que as condições são calculadas uma depois da outra, existe\num risco de que você vá para a marcha de 4 de Julho num dia chuvoso. Na\nverdade, nós devemos usar algo como isto para garantir que uma vez que\nencontremos a condição verdadeira, não passemos para as próximas.</p>\n\n<pre><code class=\"code-container\">[!java|scala|c]if (rainy()) {\n    takeUmbrella();\n} else {\n    if (hotDay()) {\n        takeWater();\n    } else {\n        if (todayIsJuly4th()) {\n            takeFlag();\n        }\n    }\n}[/!][!python]if rainy():\n    takeUmbrella()\nelse:\n    if hotDay():\n        takeWater()\n    else:\n        if todayIsJuly4th():\n            takeFlag()[/!]</code></pre>\n\n\n<p>Infelizmente, tal cascata de condicionais é bastante difícil de ler. É\nmelhor [!java|scala|c]omitir as chaves para as assertivas\n<tt>else</tt>. Algumas linguagens até mesmo introduzem uma construção\nespecífica para estes <tt>else if</tt>, mas não [!thelang].[/!]\n[!python]mudar os sub-blocos usando a palavra-chave <code>elif</code> para\nmarcar explicitamente estes ramos \"else if\".[/!]\n</p>\n\n<pre><code class=\"code-container\">[!c|java|scala]if (rainy()) { \n    takeUmbrella();\n} else if (hotDay()) {\n    takeWater();\n} else if (todayIsJuly4th()) {\n    takeFlag();\n}[/!][!python]if rainy():\n    takeUmbrella()\nelif hotDay():\n    takeWater()\nelif todayIsJuly4th():\n    takeFlag()[/!]</code></pre>\n\n<h3>Grafitagem no mundo dos Buggles</h3>\n\n<p>Os buggles podem grafitar no chão de seu mundo. Para isto, use os quatro\nmétodos seguintes:</p>\n\n<ul>\n  <li><code>[!c]int[/!][!java]boolean[/!]\nestaSobreMensagem()[!scala]:Boolean[/!]</code>: returns\n<code>[!c]1[/!][!java|scala]true[/!][!python]True[/!]</code> se e somente se\nexiste uma mensagem no chão.</li>\n  <li><code>[!c]char*[/!][!java]String[/!] lerMensagem()[!scala]:\nString[/!]</code>: retorna a mensagem lida no chão (ou uma string vazia se\nnão há nada escrito ).</li>\n  <li><code>[!java|c]void[/!] escreverMensagem([!c]char*[/!][!java]String\n[/!]msg[!scala]: String[/!])</code>: escreve a mensagem especificada no\nchão. Se já existe uma mensagem no chão, a nova é adicionada no final da\nmensagem existente.</li>\n  <li><code>[!java|c]void [/!]limparMensagem()</code>: limpa o que está escrito no\nchão.</li>\n</ul>\n\n\n<h3>Objetivo do exercício</h3>O objetivo é então organizar um jogo de BDR entre os buggles ensinando eles\na se mover de acordo com as instruções escritas no chão. Estas instruções\nsão mensagens escritas no chão, com o seguinte significado:\n\n<table border=\"1\">\n <tr><td>Mensagem</td>\n     <td>O que fazer</td>\n     <td>Mnemônico</td></tr>\n\n <tr><td>[!java|c]'R'[/!][!scala|python]\"R\"[/!]</td><td>Vire a direita (R de right) e mova um passo a frente</td><td>Direita</td></tr>\n <tr><td>[!java|c]'L'[/!][!scala|python]\"L\"[/!]</td><td>Vire a esquerda e mova um passo a frente</td><td>Esquerda</td></tr>\n <tr><td>[!java|c]'I'[/!][!scala|python]\"I\"[/!]</td><td>Vire para trás (meia-volta) e mova um passo a frente</td><td>Inversa</td></tr>\n\n <tr><td>[!java|c]'A'[/!][!scala|python]\"A\"[/!]</td><td>Mova um passo a frente</td><td>Primeira letra do alfabeto</td></tr>\n <tr><td>[!java|c]'B'[/!][!scala|python]\"B\"[/!]</td><td>Mova dois passos a frente</td><td>Segunda letra do alfabeto</td></tr>\n <tr><td>[!java|c]'C'[/!][!scala|python]\"C\"[/!]</td><td>Mova três passos a frente</td><td>Terceira letra do alfabeto</td></tr>\n\n <tr><td>[!java|c]'Z'[/!][!scala|python]\"Z\"[/!]</td><td>Mova um passo para trás</td><td>última letra do alfabeto</td></tr>\n <tr><td>[!java|c]'Y'[/!][!scala|python]\"Y\"[/!]</td><td>Mova dois passos para trás</td><td>penúltima letra do alfabeto</td></tr>\n <tr><td>[!java|c]'X'[/!][!scala|python]\"X\"[/!]</td><td>Mova três passos para trás</td><td>Antepenúltima letra do alfabeto</td></tr>\n <tr><td><i>(qualquer outra coisa)</i></td><td>Parar de dançar.</td><td></td></tr>\n</table>\n\n<h3>Indicações</h3>\n\nEste exercício pode parecer um pouco complexo à primeira vista, mas ele vem\npara resumir a informação na tabela numa sequência de condicionais.\n\n<p>Você tem que se manter dançando enquanto houverem passos de dança para\nfazer, i.e., enquanto estivermos numa célula cujo conteúdo esteja contido na\ntabela. a forma mais fácil de fazer isto é usando uma variável booleana\n(<code>terminou</code>) como condição de término para o loop\n<code>while</code>. Ela deve ser iniciada como\n<code>[!c]0[/!][!java|scala]false[/!][!python]False[/!]</code>, e trocada\npara <code>[!c]1[/!][!java|scala]true[/!][!python]True[/!]</code> assim que\no buggle encontre uma célula com um valor não descrito na tabela. Assim, o\nloop pára e o programa termina. </p>\n\n[!java|c]\n<p>Outro detalhe é que detectar se strings são iguais é um pouco chato em\nJava. Então, usamos o <code>char getIndication[!c]Bdr[/!]()</code> ao invés\ndo <code>[!java]String[/!][!c]char*[/!] lerMensagem()</code>. Este método,\nconhecido apenas pelos buggles deste exercício, retorna o primeiro caractere\nda mensagem escrita no chão (ou ' ' -- o caractere para espaço -- se não tem\nnada escrito). Ele habilita que se trabalhe com caracteres ao invés de\nstrings, que é muito mais simples em [!thelang].</p>\n[/!]\n\n<h3>Dicas</h3>\n\nSe você não entendeu por que o buggle não fez os passos esperados, tente\nadicionar <code>abaixarPincel()</code> no seu método. Isto pede ao buggle\npara abaixar um pincel deixando um rastro por onde passar. Isto pode ajudar\nvocê a entender a trajetória dele, mas não esqueça de remover esta chamada\nquando você quiser testar se seu código é uma solução válida para o\nexercício: você pode fazer o buggle dançar, mas não pichar a pista de dança.\n\n<p>Quando seu programa finalmente funcionar, vá para o próximo exercício.</p>\n",
    "en" : "<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->\n<h2>Buggle Dance Revolution (BDR)</h2>\n\n<p>After these races, it's time to party! For that, we will teach the buggles to \nplay Dance Revolution, this game beloved of some students: The player has \nto move the feet on the carpet according to the instructions presented on the \nscreen, and following the music. But before that, we have some details to study first.</p>\n\n[!java|scala|c]\n<h3>Conditionals without curly braces</h3>\n<p>\nThere is one detail we omitted about the conditional syntax: if a branch\ncontains only one instruction, then the curly braces become optional. So,\nthe two chunk of code are equivalent:</p>\n\n <pre><code class=\"code-container\">if (<b>condition</b>) {\n    <b>whatToDoIfTheConditionIsTrue();</b>\n} else {\n    <b>whatToDoElse();</b>\n}</code></pre>\n <pre><code class=\"code-container\">if (<b>condition</b>) \n    <b>whatToDoIfTheConditionIsTrue();</b>\nelse\n    <b>whatToDoElse();</b></code></pre>\n\n<p>Actually, you can do the same for loops body that are reduced to one instruction only. \nBut beware, this becomes dangerous if you chain the <tt>if</tt> instructions like this: </p>\n<pre><code class=\"code-container\">if (isOverBaggle())    \n     if (x == 5)\n          left();\nelse\n     right();\n[!c]stepForward();[/!][!java|scala]forward();[/!]</code></pre>\n\n<p>In fact, it does not turn right when there is no baggle on the ground AND x\nequals 5, but when the buggle found a baggle on the ground and x equals\nanything but 5. Putting this otherwise, the buggle understands the previous\ncode as if it were written the following way (note that the <tt>else</tt>\nwere moved to the right):</p>\n<pre><code class=\"code-container\">if (isOverBaggle())    \n        if (x == 5)\n            left();\n        else\n            right();\n[!c]stepForward();[/!][!java|scala]forward();[/!]</code></pre>\n\n<p>The first lesson of this is that the indentation is very important to help\nhumans understanding, even if it does not change the actual meaning of\nthe code. We could have written the following code and obtain the same\nresult. But if you want a human to read and review your code, you\nreally want to indent it correctly. That's for example the case if you want\na professor to read it (to grade it or to answer a question about it), or if\nyou want to reuse your code later, or even if you need to debug your code yourself.</p> \n\n<pre><code class=\"code-container\">if (isOverBaggle()) if (x == 5) left(); else right(); [!c]stepForward();[/!][!java|scala]forward();[/!]</code></pre>\n\n<p>The second lesson is that a <tt>else</tt> branch always connects to the\nclosest <tt>if</tt>. This may be a bit troublesome in some case, and it may\nbe easier to add more braces than strictly needed to remove any ambiguity.</p>\n[/!]\n\n<h3>Chaining conditionals</h3>\n\n<p>You sometimes want to ask the buggle something similar to:</p> \n<pre><code class=\"code-container\">if it's raining, take an umbrella;\nif not, and if it's a hot day, take a bottle of water;\nif not and if it's July 4th, take an American flag</code></pre>\n\n<p>The trap is that we want at most one of these actions to be taken. That is\nto say, if it's raining a very hot July 4th, we don't want the buggle to get\noutside with an umbrella, some water and a flag, but simply with an\numbrella. The following code is thus WRONG.</p>\n\n<pre><code class=\"code-container\">[!scala|c|java]if (rainy())\n    takeUmbrella();\nif (hot())\n    takeWater();\nif (todayIsJuly4th())\n    takeFlag();[/!][!python]if rainy():\n    takeUmbrella()\nif hot():\n    takeWater()\nif todayIsJuly4th():\n    takeFlag()[/!]</code></pre>\n\n\n<p>Indeed, since the conditions are evaluated one after the other, there is a\nrisk that you go to the July 4th march on a rainy day. Instead, we should\nuse something like this to ensure that once we found a true condition, we won't\nevaluate the next ones.</p>\n\n<pre><code class=\"code-container\">[!java|scala|c]if (rainy()) {\n    takeUmbrella();\n} else {\n    if (hotDay()) {\n        takeWater();\n    } else {\n        if (todayIsJuly4th()) {\n            takeFlag();\n        }\n    }\n}[/!][!python]if rainy():\n    takeUmbrella()\nelse:\n    if hotDay():\n        takeWater()\n    else:\n        if todayIsJuly4th():\n            takeFlag()[/!]</code></pre>\n\n\n<p>Unfortunately, such a cascade of conditionals is quite difficult to read. It is better to \n[!java|scala|c]omit the curly braces for the <tt>else</tt> statements. Some languages\neven introduce a specific construct for these <tt>else if</tt>, but not [!thelang].[/!]\n[!python]change the sub-blocks using the <code>elif</code> keyword to mark\nexplicitly these \"else if\" branches.[/!]\n</p>\n\n<pre><code class=\"code-container\">[!c|java|scala]if (rainy()) { \n    takeUmbrella();\n} else if (hotDay()) {\n    takeWater();\n} else if (todayIsJuly4th()) {\n    takeFlag();\n}[/!][!python]if rainy():\n    takeUmbrella()\nelif hotDay():\n    takeWater()\nelif todayIsJuly4th():\n    takeFlag()[/!]</code></pre>\n\n<h3>Graffiti in the Buggle World</h3>\n\n<p>Buggles can tag graffitis on the ground of their world. For that, they use\nthe four following methods:</p>\n\n<ul>\n  <li><code>[!c]int[/!][!java]boolean[/!] isOverMessage()[!scala]:Boolean[/!]</code>: \n    returns <code>[!c]1[/!][!java|scala]true[/!][!python]True[/!]</code> if and only if there is a\n    message on the ground.</li>\n  <li><code>[!c]char*[/!][!java]String[/!] readMessage()[!scala]: String[/!]</code>: \n    returns the message written on the ground (or an empty string if nothing is written).</li>\n  <li><code>[!java|c]void[/!] writeMessage([!c]char*[/!][!java]String [/!]msg[!scala]: String[/!])</code>:\n    writes the specified message down on the ground. If there is already a message on the\n    ground, the new content is added at the end of the existing message.</li>\n  <li><code>[!java|c]void [/!]clearMessage()</code>: clears what is written on the ground.</li>\n</ul>\n\n\n<h3>Exercise goal</h3>The goal is then to organize a BDR game between the\nbuggles by teaching them to move according to the instructions written on\nthe ground. These instructions are messages written on the ground, with the\nfollowing signification:\n\n<table border=\"1\">\n <tr><td>Message</td>\n     <td>What to do</td>\n     <td>Mnemonic</td></tr>\n\n <tr><td>[!java|c]'R'[/!][!scala|python]\"R\"[/!]</td><td>Turn right and move one step forward</td><td>Right</td></tr>\n <tr><td>[!java|c]'L'[/!][!scala|python]\"L\"[/!]</td><td>Turn left and move one step forward</td><td>Left</td></tr>\n <tr><td>[!java|c]'I'[/!][!scala|python]\"I\"[/!]</td><td>Turn back (U-turn) and move one step forward</td><td>Inverse</td></tr>\n\n <tr><td>[!java|c]'A'[/!][!scala|python]\"A\"[/!]</td><td>Move one step forward</td><td>First letter of the alphabet</td></tr>\n <tr><td>[!java|c]'B'[/!][!scala|python]\"B\"[/!]</td><td>Move two steps forward</td><td>Second letter of the alphabet</td></tr>\n <tr><td>[!java|c]'C'[/!][!scala|python]\"C\"[/!]</td><td>Move three steps forward</td><td>Third letter of the alphabet</td></tr>\n\n <tr><td>[!java|c]'Z'[/!][!scala|python]\"Z\"[/!]</td><td>Move one step backward</td><td>One letter before the end of the alphabet</td></tr>\n <tr><td>[!java|c]'Y'[/!][!scala|python]\"Y\"[/!]</td><td>Move two steps backward</td><td>Two letters before the end of the alphabet</td></tr>\n <tr><td>[!java|c]'X'[/!][!scala|python]\"X\"[/!]</td><td>Move three steps backward</td><td>Three letters before the end of the alphabet</td></tr>\n <tr><td><i>(anything else)</i></td><td>Stop dancing.</td><td></td></tr>\n</table>\n\n<h3>Indications</h3>\n\nThis exercise may seem a bit complex at the first glance, but it comes down\nto summarizing the information of the table in a sequence of conditionals.\n\n<p>You have to keep dancing as long as there is some dancing steps to do,\ni.e., as long as we are in a cell which content is described in the table. \nThe easier for that is to use a boolean variable (<code>finished</code>)\nas termination condition to a <code>while</code> loop.\nIt should be initialized to <code>[!c]0[/!][!java|scala]false[/!][!python]False[/!]</code>, and \nswitched to <code>[!c]1[/!][!java|scala]true[/!][!python]True[/!]</code>\nas soon as the buggle find a cell with a value not described in the table.\nThus, the loop will stop and the program will terminate. </p>\n\n[!java|c]\n<p>Another subtlety is that detecting if strings are equals is a bit annoying in [!thelang].\nSo, we use the <code>char getIndication[!c]Bdr[/!]()</code> instead of <code>[!java]String[/!][!c]char*[/!] readMessage()</code>. \n\nThis method, only known by the buggles of this exercise, returns the first char of the message written on the ground \n(or ' ' -- the space char --  if nothing is written down). It enables to work with chars instead of strings, that is \nmuch simpler in [!thelang].</p>\n[/!]\n\n<h3>Tips and Hints</h3>\n\nIf you fail to understand why the buggle does not execute the expected\nsteps, try adding <code>brushDown()</code> in your method. This asks the\nbuggle to put down a brush leaving a trail when it moves. It should help you\nunderstanding its trajectory, but do not forget to remove this call when you\nwant to test whether your code is a valid solution to the exercise: you are\nasked to let the buggle dance, not to vandalize the dance floor.\n\n<p>When your program finally works, move on to the next exercise.</p>\n",
    "fr" : "\n<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->\n<h2>Buggle Dance Revolution (BDR)</h2>\n\n<p>Après toutes ces courses, il est temps de faire la fête ! Pour cela, nous\nallons apprendre à nos buggles à jouer à Dance Revolution, ce jeu très prisé\nde certains étudiants où le joueur doit bouger sur un tapis prévu à cet\neffet en fonction des consignes présentées à l'écran en rythme avec la\nmusique. Mais avant cela, nous avons quelques détails à étudier.</p>\n\n[!java|scala|c]\n<h3>Conditionnelles sans accolades</h3>\n<p>\nIl y a un détail que nous avons omis à propos de la syntaxe des\nconditionnelles : si une branche ne contient qu'une seule instruction, les\naccolades sont optionnelles. Ainsi, les deux extraits suivants sont\néquivalents:</p>\n\n <pre><code class=\"code-container\">if (<b>condition</b>) {\n    <b>quoiFaireSiLaConditionEstVraie();</b>\n} else {\n    <b>quoiFaireSinon();</b>\n}</code></pre>\n <pre><code class=\"code-container\">if (<b>condition</b>)\n    <b>quoiFaireSiLaConditionEstVraie();</b>\nelse\n    <b>quoiFaireSinon();</b></code></pre>\n\n<p>Vous pouvez faire de même avec les boucles dont le corps se réduit à une\nseule instruction. Mais attention, ceci peut être dangereux si on enchaîne\nles <tt>if</tt> comme dans l'exemple suivant. </p>\n<pre><code class=\"code-container\">if (estSurBiscuit())    \n     if (x == 5)\n          gauche();\nelse\n     droite();\n[!c]avancePas();[/!][!java|scala]avance();[/!]</code></pre>\n\n<p>En fait, ça ne tourne pas à droite quand il n'y a pas un baggle par terre ET\nque x vaut 5, mais quand la buggle a trouvé un baggle, et que x vaut une\nautre valeur. Autrement dit, la buggle lit le code précédent comme suit\n(notez que le <tt>else</tt> est décalé vers la droite par rapport à\nprécédemment) :</p>\n<pre><code class=\"code-container\">if (estSurBiscuit())    \n        if (x == 5)\n            gauche();\n        else\n            droite();\n[!c]avancePas();[/!][!java|scala]avance();[/!]</code></pre>\n\n<p>La première leçon, c'est que l'indentation est très importante pour que les\nhumains puissent comprendre le code, mais elle ne change pas la\nsignification du code pour la machine. On aurait tout aussi bien pu écrire\nle code suivant et obtenir le même résultat. Mais attention, si on veut\nqu'un humain puisse relire le code, l'indentation est quasi\nindispensable. C'est par exemple le cas si votre code doit être relu par un\nprofesseur (pour qu'il le note ou pour lui poser une question), ou si vous\ncomptez réutiliser votre code plus tard, ou même si vous devez debugger\nvotre propre code après l'avoir écrit.</p> \n\n<pre><code class=\"code-container\">if (estSurBiscuit()) if (x == 5) gauche(); else droite(); [!c]avancePas();[/!][!java|scala]avance();[/!]</code></pre>\n\n<p>La seconde leçon, c'est qu'une branche <tt>else</tt> se raccroche toujours\nau <tt>if</tt> le plus proche. C'est parfois un peu contre-intuitif, et il\nest préférable d'ajouter plus d'accolades que nécessaire pour lever toute\nambiguïté.</p>\n[/!]\n\n<h3>Enchaînements de conditionnelles</h3>\n\n<p>Il arrive que l'on veuille demander à la buggle quelque chose similaire à :</p> \n<pre><code class=\"code-container\">s'il pleut, prend un parapluie; \nsi non, s'il fait chaud, prend une bouteille d'eau; \nsi non, si nous sommes le 14 juillet, prend un drapeau français</code></pre>\n\n<p>Le piège étant que nous voudrions qu'au plus l'une de ces actions soient\nréalisées. C'est à dire, que s'il pleut un 14 juillet très chaud, on ne veut\npas que la buggle sorte avec un parapluie, de l'eau et un drapeau, mais\njuste avec un parapluie. Le code suivant est donc faux.</p>\n\n<pre><code class=\"code-container\">[!java|c|scala]if (ilPleut())\n    prendreParapluie();\nif (ilFaitChaud())\n    prendreDeLEau();\nif (sommes14Juillet())\n    prendreDrapeau();[/!][!python]if ilPleut():\n    prendreParapluie()\nif ilFaitChaud():\n    prendreDeLEau()\nif sommes14Juillet():\n    prendreDrapeau()[/!]</code></pre>\n\n\n<p>En effet, toutes les conditions sont évaluées les unes après les autres, et\non risque donc d'aller au défilé un jour de pluie. À la place, il faut donc\nécrire quelque chose comme ce qui suit pour s'assurer que si l'on trouve une\ncondition vraie, on n'évalue pas les suivants.</p>\n\n<pre><code class=\"code-container\">[!java|scala|c]if (ilPleut()) {\n    prendreParapluie();\n} else {\n    if (ilFaitChaud()) {\n        prendreDeLEau();\n    } else {\n        if (sommes14Juillet()) {\n            prendreDrapeau();\n        }\n    }\n}[/!][!python]if ilPleut():\n    prendreParapluie()\nelse:\n    if ilFaitChaud():\n        prendreDeLEau()\n    else:\n        if sommes14Juillet():\n            prendreDrapeau()[/!]</code></pre>\n\n\n<p>Une telle cascade de conditionnelles est un peu difficile à lire, et il est\npréférable\n[!java|scala|c] d'omettre les accolades associées aux <tt>else</tt> comme\nsuit. Il y a même certains langages qui introduisent un mot-clé spécial pour\nces <tt>else if</tt> (mais pas [!thelang]).[/!]\n[!python] d'introduire les sous-blocs avec le mot-clé <code>elif</code>\n(abréviation de «else if») pour expliciter ces branches «sinon si».[/!]\n</p>\n\n<pre><code class=\"code-container\">[!c|java|scala]if (ilPleut()) { \n    prendreParapluie();\n} else if (ilFaitChaud()) {\n    prendreDeLEau();\n} else if (sommes14Juillet()) {\n    prendreDrapeau();\n}[/!][!python]if ilPleut():\n    prendreDrapeau()\nelif ilFaitChaud():\n    prendreDeLEau()\nelif sommes14Juillet():\n    prendreDrapeau()[/!]</code></pre>\n\n<h3>Les graffitis dans le monde des buggles</h3>\n\n<p>Les buggles peuvent écrire des choses par terre dans leur monde. Pour ce\nfaire, elles utilisent les quatre méthodes suivantes:</p>\n\n<ul>\n  <li><code>[!c]int[/!][!java]boolean[/!]\nestSurMessage()[!scala]:Boolean[/!]</code>: renvoie\n<code>[!c]1[/!][!java|scala]true[/!][!python]True[/!]</code> si et seulement\ns'il y a un message écrit par terre.</li>\n  <li><code>[!c]char*[/!][!java]String [/!]litMessage()[!scala]: String[/!]</code>\n: renvoie le message qu'il y a écrit par terre (s'il y a rien, on obtient\nune chaîne vide).</li>\n  <li><code>[!java|c]void[/!] ecritMessage([!c]char*[/!][!java]String\n[/!]msg[!scala]: String[/!])</code> : écrit le message spécifié en argument\npar terre. S'il y a déjà quelque chose écrit par terre, on ajoute le nouveau\nmessage à la fin du précédent.</li>\n  <li><code>[!java|c]void [/!]clearMessage()</code> : efface ce qui est écrit par\nterre.</li>\n</ul>\n\n\n<h3>Objectif de cet exercice</h3>L'objectif est donc d'organiser une partie de BDR entre les buggles en leur\napprenant à bouger en fonction des indications écrites par terre.  Ces\nindications sont des messages au sol, avec le code suivant:\n\n<table border=\"1\">\n <tr><td>Indication</td>\n     <td>Quoi faire</td>\n     <td>Mnémotechnique</td></tr>\n\n <tr><td>[!java|c]'R'[/!][!scala|python]\"R\"[/!]</td><td>Tourner à droite et avancer d'une case</td><td>Right (signifie «droite» en anglais)</td></tr>\n <tr><td>[!java|c]'L'[/!][!scala|python]\"L\"[/!]</td><td>Tourner à gauche et avancer d'une case</td><td>Left (signifie «gauche» en anglais)</td></tr>\n <tr><td>[!java|c]'I'[/!][!scala|python]\"I\"[/!]</td><td>Se retourner (demi-tour) et avancer d'une case</td><td>Inverse</td></tr>\n\n <tr><td>[!java|c]'A'[/!][!scala|python]\"A\"[/!]</td><td>Avancer d'une case</td><td>Première lettre de l'alphabet</td></tr>\n <tr><td>[!java|c]'B'[/!][!scala|python]\"B\"[/!]</td><td>Avancer de deux cases</td><td>Deuxième lettre de l'alphabet</td></tr>\n <tr><td>[!java|c]'C'[/!][!scala|python]\"C\"[/!]</td><td>Avancer de trois cases</td><td>Troisième lettre de l'alphabet</td></tr>\n\n <tr><td>[!java|c]'Z'[/!][!scala|python]\"Z\"[/!]</td><td>Reculer d'une case</td><td>A une lettre de la fin de l'alphabet</td></tr>\n <tr><td>[!java|c]'Y'[/!][!scala|python]\"Y\"[/!]</td><td>Reculer de deux cases</td><td>A deux lettres de la fin de l'alphabet</td></tr>\n <tr><td>[!java|c]'X'[/!][!scala|python]\"X\"[/!]</td><td>Reculer de trois cases</td><td>A trois lettres de la fin de l'alphabet</td></tr>\n <tr><td><i>(n'importe quoi d'autre)</i></td><td>Arrêter de danser.</td><td></td></tr>\n</table>\n\n<h3>Indications</h3>\n\nCet exercice peut sembler un peu compliqué, mais il s'agit principalement de\ntraduire le contenu du tableau ci-dessus dans un enchaînement de\nconditionnelles.\n\n<p>Vous devez continuer à danser tant qu'il reste des pas de danse à\nfaire. c-à-d tant qu'on est sur une case décrite dans le tableau. Le plus\nsimple pour cela est d'utiliser une variable booléenne (<code>fini</code>)\nen condition d'arrêt d'une boucle while. Cette variable est initialisée à la\nvaleur faux\n(<code>[!c]0[/!][!java|scala]false[/!][!python]False[/!]</code>). Si on\ntrouve une case ne répondant à aucune ligne du tableau, on change la valeur\nde cette variable à vrai\n(<code>[!c]1[/!][!java|scala]true[/!][!python]True[/!]</code>). Cela arrête\nla boucle, et le programme. </p>\n\n[!java|c]\n<p>Une autre subtilité est qu'il est un peu pénible en Java de déterminer si\ndeux chaînes de caractères sont identiques. Nous utiliserons donc la méthode\n<code>char getIndication[!c]Bdr[/!]()</code> à la place de\n<code>[!java]String[/!][!c]char*[/!] litMessage()</code>. Cette méthode, qui\nn'est connue que des buggles des exercices BDR, renvoie le premier caractère\ndu message au sol (ou ' ' --une espace-- s'il n'y a rien d'écrit au\nsol). Cela nous permet de travailler avec des caractères\n(<code>char</code>), qui sont moins pénibles que les chaînes en [!thelang].</p>\n[/!]\n\n<h3>Trucs et astuces</h3>\n\nSi vous ne parvenez plus à comprendre pourquoi votre buggle n'exécute pas\nles pas de danse demandés, essayez d'ajouter <code>baisseBrosse()</code>\ndans votre méthode. Cela demandera à la buggle de poser une brosse par\nterre, laissant une trace au sol quand elle avance. Cela devrait vous aider\nà suivre sa trajectoire, mais pensez à retirer cette appel lorsque vous\nvoulez tester si votre solution marche : on vous demande de faire danser les\nbuggles, pas de dégrader le dance floor.\n\n<p>Quand votre programme fonctionne enfin, passez à l'exercice suivant.</p>\n"
  }
}